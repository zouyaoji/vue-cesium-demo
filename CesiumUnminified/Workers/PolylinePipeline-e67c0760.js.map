{"version":3,"file":"PolylinePipeline-e67c0760.js","sources":["../../../../Source/Core/PolylinePipeline.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\n\n/**\n * @private\n */\nconst PolylinePipeline = {};\n\nPolylinePipeline.numberOfPoints = function (p0, p1, minDistance) {\n  const distance = Cartesian3.distance(p0, p1);\n  return Math.ceil(distance / minDistance);\n};\n\nPolylinePipeline.numberOfPointsRhumbLine = function (p0, p1, granularity) {\n  const radiansDistanceSquared =\n    Math.pow(p0.longitude - p1.longitude, 2) +\n    Math.pow(p0.latitude - p1.latitude, 2);\n\n  return Math.max(\n    1,\n    Math.ceil(Math.sqrt(radiansDistanceSquared / (granularity * granularity)))\n  );\n};\n\nconst cartoScratch = new Cartographic();\nPolylinePipeline.extractHeights = function (positions, ellipsoid) {\n  const length = positions.length;\n  const heights = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const p = positions[i];\n    heights[i] = ellipsoid.cartesianToCartographic(p, cartoScratch).height;\n  }\n  return heights;\n};\n\nconst wrapLongitudeInversMatrix = new Matrix4();\nconst wrapLongitudeOrigin = new Cartesian3();\nconst wrapLongitudeXZNormal = new Cartesian3();\nconst wrapLongitudeXZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst wrapLongitudeYZNormal = new Cartesian3();\nconst wrapLongitudeYZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst wrapLongitudeIntersection = new Cartesian3();\nconst wrapLongitudeOffset = new Cartesian3();\n\nconst subdivideHeightsScratchArray = [];\n\nfunction subdivideHeights(numPoints, h0, h1) {\n  const heights = subdivideHeightsScratchArray;\n  heights.length = numPoints;\n\n  let i;\n  if (h0 === h1) {\n    for (i = 0; i < numPoints; i++) {\n      heights[i] = h0;\n    }\n    return heights;\n  }\n\n  const dHeight = h1 - h0;\n  const heightPerVertex = dHeight / numPoints;\n\n  for (i = 0; i < numPoints; i++) {\n    const h = h0 + i * heightPerVertex;\n    heights[i] = h;\n  }\n\n  return heights;\n}\n\nconst carto1 = new Cartographic();\nconst carto2 = new Cartographic();\nconst cartesian = new Cartesian3();\nconst scaleFirst = new Cartesian3();\nconst scaleLast = new Cartesian3();\nconst ellipsoidGeodesic = new EllipsoidGeodesic();\nlet ellipsoidRhumb = new EllipsoidRhumbLine();\n\n//Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\n//Result includes p1, but not include p2.  This function is called for a sequence of line segments,\n//and this prevents duplication of end point.\nfunction generateCartesianArc(\n  p0,\n  p1,\n  minDistance,\n  ellipsoid,\n  h0,\n  h1,\n  array,\n  offset\n) {\n  const first = ellipsoid.scaleToGeodeticSurface(p0, scaleFirst);\n  const last = ellipsoid.scaleToGeodeticSurface(p1, scaleLast);\n  const numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);\n  const start = ellipsoid.cartesianToCartographic(first, carto1);\n  const end = ellipsoid.cartesianToCartographic(last, carto2);\n  const heights = subdivideHeights(numPoints, h0, h1);\n\n  ellipsoidGeodesic.setEndPoints(start, end);\n  const surfaceDistanceBetweenPoints =\n    ellipsoidGeodesic.surfaceDistance / numPoints;\n\n  let index = offset;\n  start.height = h0;\n  let cart = ellipsoid.cartographicToCartesian(start, cartesian);\n  Cartesian3.pack(cart, array, index);\n  index += 3;\n\n  for (let i = 1; i < numPoints; i++) {\n    const carto = ellipsoidGeodesic.interpolateUsingSurfaceDistance(\n      i * surfaceDistanceBetweenPoints,\n      carto2\n    );\n    carto.height = heights[i];\n    cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n    Cartesian3.pack(cart, array, index);\n    index += 3;\n  }\n\n  return index;\n}\n\n//Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\n//Result includes p1, but not include p2.  This function is called for a sequence of line segments,\n//and this prevents duplication of end point.\nfunction generateCartesianRhumbArc(\n  p0,\n  p1,\n  granularity,\n  ellipsoid,\n  h0,\n  h1,\n  array,\n  offset\n) {\n  const start = ellipsoid.cartesianToCartographic(p0, carto1);\n  const end = ellipsoid.cartesianToCartographic(p1, carto2);\n  const numPoints = PolylinePipeline.numberOfPointsRhumbLine(\n    start,\n    end,\n    granularity\n  );\n  start.height = 0.0;\n  end.height = 0.0;\n  const heights = subdivideHeights(numPoints, h0, h1);\n\n  if (!ellipsoidRhumb.ellipsoid.equals(ellipsoid)) {\n    ellipsoidRhumb = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  }\n  ellipsoidRhumb.setEndPoints(start, end);\n  const surfaceDistanceBetweenPoints =\n    ellipsoidRhumb.surfaceDistance / numPoints;\n\n  let index = offset;\n  start.height = h0;\n  let cart = ellipsoid.cartographicToCartesian(start, cartesian);\n  Cartesian3.pack(cart, array, index);\n  index += 3;\n\n  for (let i = 1; i < numPoints; i++) {\n    const carto = ellipsoidRhumb.interpolateUsingSurfaceDistance(\n      i * surfaceDistanceBetweenPoints,\n      carto2\n    );\n    carto.height = heights[i];\n    cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n    Cartesian3.pack(cart, array, index);\n    index += 3;\n  }\n\n  return index;\n}\n\n/**\n * Breaks a {@link Polyline} into segments such that it does not cross the &plusmn;180 degree meridian of an ellipsoid.\n *\n * @param {Cartesian3[]} positions The polyline's Cartesian positions.\n * @param {Matrix4} [modelMatrix=Matrix4.IDENTITY] The polyline's model matrix. Assumed to be an affine\n * transformation matrix, where the upper left 3x3 elements are a rotation matrix, and\n * the upper three elements in the fourth column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].\n * The matrix is not verified to be in the proper form.\n * @returns {Object} An object with a <code>positions</code> property that is an array of positions and a\n * <code>segments</code> property.\n *\n *\n * @example\n * const polylines = new Cesium.PolylineCollection();\n * const polyline = polylines.add(...);\n * const positions = polyline.positions;\n * const modelMatrix = polylines.modelMatrix;\n * const segments = Cesium.PolylinePipeline.wrapLongitude(positions, modelMatrix);\n *\n * @see PolygonPipeline.wrapLongitude\n * @see Polyline\n * @see PolylineCollection\n */\nPolylinePipeline.wrapLongitude = function (positions, modelMatrix) {\n  const cartesians = [];\n  const segments = [];\n\n  if (defined(positions) && positions.length > 0) {\n    modelMatrix = defaultValue(modelMatrix, Matrix4.IDENTITY);\n    const inverseModelMatrix = Matrix4.inverseTransformation(\n      modelMatrix,\n      wrapLongitudeInversMatrix\n    );\n\n    const origin = Matrix4.multiplyByPoint(\n      inverseModelMatrix,\n      Cartesian3.ZERO,\n      wrapLongitudeOrigin\n    );\n    const xzNormal = Cartesian3.normalize(\n      Matrix4.multiplyByPointAsVector(\n        inverseModelMatrix,\n        Cartesian3.UNIT_Y,\n        wrapLongitudeXZNormal\n      ),\n      wrapLongitudeXZNormal\n    );\n    const xzPlane = Plane.fromPointNormal(\n      origin,\n      xzNormal,\n      wrapLongitudeXZPlane\n    );\n    const yzNormal = Cartesian3.normalize(\n      Matrix4.multiplyByPointAsVector(\n        inverseModelMatrix,\n        Cartesian3.UNIT_X,\n        wrapLongitudeYZNormal\n      ),\n      wrapLongitudeYZNormal\n    );\n    const yzPlane = Plane.fromPointNormal(\n      origin,\n      yzNormal,\n      wrapLongitudeYZPlane\n    );\n\n    let count = 1;\n    cartesians.push(Cartesian3.clone(positions[0]));\n    let prev = cartesians[0];\n\n    const length = positions.length;\n    for (let i = 1; i < length; ++i) {\n      const cur = positions[i];\n\n      // intersects the IDL if either endpoint is on the negative side of the yz-plane\n      if (\n        Plane.getPointDistance(yzPlane, prev) < 0.0 ||\n        Plane.getPointDistance(yzPlane, cur) < 0.0\n      ) {\n        // and intersects the xz-plane\n        const intersection = IntersectionTests.lineSegmentPlane(\n          prev,\n          cur,\n          xzPlane,\n          wrapLongitudeIntersection\n        );\n        if (defined(intersection)) {\n          // move point on the xz-plane slightly away from the plane\n          const offset = Cartesian3.multiplyByScalar(\n            xzNormal,\n            5.0e-9,\n            wrapLongitudeOffset\n          );\n          if (Plane.getPointDistance(xzPlane, prev) < 0.0) {\n            Cartesian3.negate(offset, offset);\n          }\n\n          cartesians.push(\n            Cartesian3.add(intersection, offset, new Cartesian3())\n          );\n          segments.push(count + 1);\n\n          Cartesian3.negate(offset, offset);\n          cartesians.push(\n            Cartesian3.add(intersection, offset, new Cartesian3())\n          );\n          count = 1;\n        }\n      }\n\n      cartesians.push(Cartesian3.clone(positions[i]));\n      count++;\n\n      prev = cur;\n    }\n\n    segments.push(count);\n  }\n\n  return {\n    positions: cartesians,\n    lengths: segments,\n  };\n};\n\n/**\n * Subdivides polyline and raises all points to the specified height.  Returns an array of numbers to represent the positions.\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n * @returns {Number[]} A new array of positions of type {Number} that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateArc = function (options) {\n  if (!defined(options)) {\n    options = {};\n  }\n  const positions = options.positions;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = positions.length;\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  let height = defaultValue(options.height, 0);\n  const hasHeightArray = Array.isArray(height);\n\n  if (length < 1) {\n    return [];\n  } else if (length === 1) {\n    const p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\n    height = hasHeightArray ? height[0] : height;\n    if (height !== 0) {\n      const n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\n      Cartesian3.multiplyByScalar(n, height, n);\n      Cartesian3.add(p, n, p);\n    }\n\n    return [p.x, p.y, p.z];\n  }\n\n  let minDistance = options.minDistance;\n  if (!defined(minDistance)) {\n    const granularity = defaultValue(\n      options.granularity,\n      CesiumMath.RADIANS_PER_DEGREE\n    );\n    minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n  }\n\n  let numPoints = 0;\n  let i;\n\n  for (i = 0; i < length - 1; i++) {\n    numPoints += PolylinePipeline.numberOfPoints(\n      positions[i],\n      positions[i + 1],\n      minDistance\n    );\n  }\n\n  const arrayLength = (numPoints + 1) * 3;\n  const newPositions = new Array(arrayLength);\n  let offset = 0;\n\n  for (i = 0; i < length - 1; i++) {\n    const p0 = positions[i];\n    const p1 = positions[i + 1];\n\n    const h0 = hasHeightArray ? height[i] : height;\n    const h1 = hasHeightArray ? height[i + 1] : height;\n\n    offset = generateCartesianArc(\n      p0,\n      p1,\n      minDistance,\n      ellipsoid,\n      h0,\n      h1,\n      newPositions,\n      offset\n    );\n  }\n\n  subdivideHeightsScratchArray.length = 0;\n\n  const lastPoint = positions[length - 1];\n  const carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\n  carto.height = hasHeightArray ? height[length - 1] : height;\n  const cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n  Cartesian3.pack(cart, newPositions, arrayLength - 3);\n\n  return newPositions;\n};\n\nconst scratchCartographic0 = new Cartographic();\nconst scratchCartographic1 = new Cartographic();\n\n/**\n * Subdivides polyline and raises all points to the specified height using Rhumb lines.  Returns an array of numbers to represent the positions.\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n * @returns {Number[]} A new array of positions of type {Number} that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateRhumbArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateRhumbArc = function (options) {\n  if (!defined(options)) {\n    options = {};\n  }\n  const positions = options.positions;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = positions.length;\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  let height = defaultValue(options.height, 0);\n  const hasHeightArray = Array.isArray(height);\n\n  if (length < 1) {\n    return [];\n  } else if (length === 1) {\n    const p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\n    height = hasHeightArray ? height[0] : height;\n    if (height !== 0) {\n      const n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\n      Cartesian3.multiplyByScalar(n, height, n);\n      Cartesian3.add(p, n, p);\n    }\n\n    return [p.x, p.y, p.z];\n  }\n\n  const granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n\n  let numPoints = 0;\n  let i;\n\n  let c0 = ellipsoid.cartesianToCartographic(\n    positions[0],\n    scratchCartographic0\n  );\n  let c1;\n  for (i = 0; i < length - 1; i++) {\n    c1 = ellipsoid.cartesianToCartographic(\n      positions[i + 1],\n      scratchCartographic1\n    );\n    numPoints += PolylinePipeline.numberOfPointsRhumbLine(c0, c1, granularity);\n    c0 = Cartographic.clone(c1, scratchCartographic0);\n  }\n\n  const arrayLength = (numPoints + 1) * 3;\n  const newPositions = new Array(arrayLength);\n  let offset = 0;\n\n  for (i = 0; i < length - 1; i++) {\n    const p0 = positions[i];\n    const p1 = positions[i + 1];\n\n    const h0 = hasHeightArray ? height[i] : height;\n    const h1 = hasHeightArray ? height[i + 1] : height;\n\n    offset = generateCartesianRhumbArc(\n      p0,\n      p1,\n      granularity,\n      ellipsoid,\n      h0,\n      h1,\n      newPositions,\n      offset\n    );\n  }\n\n  subdivideHeightsScratchArray.length = 0;\n\n  const lastPoint = positions[length - 1];\n  const carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\n  carto.height = hasHeightArray ? height[length - 1] : height;\n  const cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n  Cartesian3.pack(cart, newPositions, arrayLength - 3);\n\n  return newPositions;\n};\n\n/**\n * Subdivides polyline and raises all points to the specified height. Returns an array of new {Cartesian3} positions.\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateCartesianArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateCartesianArc = function (options) {\n  const numberArray = PolylinePipeline.generateArc(options);\n  const size = numberArray.length / 3;\n  const newPositions = new Array(size);\n  for (let i = 0; i < size; i++) {\n    newPositions[i] = Cartesian3.unpack(numberArray, i * 3);\n  }\n  return newPositions;\n};\n\n/**\n * Subdivides polyline and raises all points to the specified height using Rhumb Lines. Returns an array of new {Cartesian3} positions.\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateCartesianRhumbArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateCartesianRhumbArc = function (options) {\n  const numberArray = PolylinePipeline.generateRhumbArc(options);\n  const size = numberArray.length / 3;\n  const newPositions = new Array(size);\n  for (let i = 0; i < size; i++) {\n    newPositions[i] = Cartesian3.unpack(numberArray, i * 3);\n  }\n  return newPositions;\n};\nexport default PolylinePipeline;\n"],"names":["Cartesian3","Cartographic","Matrix4","Plane","EllipsoidGeodesic","EllipsoidRhumbLine","defined","defaultValue","IntersectionTests","DeveloperError","Ellipsoid","CesiumMath"],"mappings":"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"}