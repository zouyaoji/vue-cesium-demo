{"version":3,"file":"createGroundPolylineGeometry.js","sources":["../../../../Source/Core/GeographicTilingScheme.js","../../../../Source/Core/ApproximateTerrainHeights.js","../../../../Source/Core/GroundPolylineGeometry.js","../../../../Source/WorkersES6/createGroundPolylineGeometry.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport CesiumMath from \"./Math.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * A tiling scheme for geometry referenced to a simple {@link GeographicProjection} where\n * longitude and latitude are directly mapped to X and Y.  This projection is commonly\n * known as geographic, equirectangular, equidistant cylindrical, or plate carr√©e.\n *\n * @alias GeographicTilingScheme\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid whose surface is being tiled. Defaults to\n * the WGS84 ellipsoid.\n * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the tiling scheme.\n * @param {Number} [options.numberOfLevelZeroTilesX=2] The number of tiles in the X direction at level zero of\n * the tile tree.\n * @param {Number} [options.numberOfLevelZeroTilesY=1] The number of tiles in the Y direction at level zero of\n * the tile tree.\n */\nfunction GeographicTilingScheme(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  this._rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);\n  this._projection = new GeographicProjection(this._ellipsoid);\n  this._numberOfLevelZeroTilesX = defaultValue(\n    options.numberOfLevelZeroTilesX,\n    2\n  );\n  this._numberOfLevelZeroTilesY = defaultValue(\n    options.numberOfLevelZeroTilesY,\n    1\n  );\n}\n\nObject.defineProperties(GeographicTilingScheme.prototype, {\n  /**\n   * Gets the ellipsoid that is tiled by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the rectangle, in radians, covered by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {Rectangle}\n   */\n  rectangle: {\n    get: function () {\n      return this._rectangle;\n    },\n  },\n\n  /**\n   * Gets the map projection used by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {MapProjection}\n   */\n  projection: {\n    get: function () {\n      return this._projection;\n    },\n  },\n});\n\n/**\n * Gets the total number of tiles in the X direction at a specified level-of-detail.\n *\n * @param {Number} level The level-of-detail.\n * @returns {Number} The number of tiles in the X direction at the given level.\n */\nGeographicTilingScheme.prototype.getNumberOfXTilesAtLevel = function (level) {\n  return this._numberOfLevelZeroTilesX << level;\n};\n\n/**\n * Gets the total number of tiles in the Y direction at a specified level-of-detail.\n *\n * @param {Number} level The level-of-detail.\n * @returns {Number} The number of tiles in the Y direction at the given level.\n */\nGeographicTilingScheme.prototype.getNumberOfYTilesAtLevel = function (level) {\n  return this._numberOfLevelZeroTilesY << level;\n};\n\n/**\n * Transforms a rectangle specified in geodetic radians to the native coordinate system\n * of this tiling scheme.\n *\n * @param {Rectangle} rectangle The rectangle to transform.\n * @param {Rectangle} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the native rectangle if 'result'\n *          is undefined.\n */\nGeographicTilingScheme.prototype.rectangleToNativeRectangle = function (\n  rectangle,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  const west = CesiumMath.toDegrees(rectangle.west);\n  const south = CesiumMath.toDegrees(rectangle.south);\n  const east = CesiumMath.toDegrees(rectangle.east);\n  const north = CesiumMath.toDegrees(rectangle.north);\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates\n * of the tiling scheme.\n *\n * @param {Number} x The integer x coordinate of the tile.\n * @param {Number} y The integer y coordinate of the tile.\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\n *          if 'result' is undefined.\n */\nGeographicTilingScheme.prototype.tileXYToNativeRectangle = function (\n  x,\n  y,\n  level,\n  result\n) {\n  const rectangleRadians = this.tileXYToRectangle(x, y, level, result);\n  rectangleRadians.west = CesiumMath.toDegrees(rectangleRadians.west);\n  rectangleRadians.south = CesiumMath.toDegrees(rectangleRadians.south);\n  rectangleRadians.east = CesiumMath.toDegrees(rectangleRadians.east);\n  rectangleRadians.north = CesiumMath.toDegrees(rectangleRadians.north);\n  return rectangleRadians;\n};\n\n/**\n * Converts tile x, y coordinates and level to a cartographic rectangle in radians.\n *\n * @param {Number} x The integer x coordinate of the tile.\n * @param {Number} y The integer y coordinate of the tile.\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\n *          if 'result' is undefined.\n */\nGeographicTilingScheme.prototype.tileXYToRectangle = function (\n  x,\n  y,\n  level,\n  result\n) {\n  const rectangle = this._rectangle;\n\n  const xTiles = this.getNumberOfXTilesAtLevel(level);\n  const yTiles = this.getNumberOfYTilesAtLevel(level);\n\n  const xTileWidth = rectangle.width / xTiles;\n  const west = x * xTileWidth + rectangle.west;\n  const east = (x + 1) * xTileWidth + rectangle.west;\n\n  const yTileHeight = rectangle.height / yTiles;\n  const north = rectangle.north - y * yTileHeight;\n  const south = rectangle.north - (y + 1) * yTileHeight;\n\n  if (!defined(result)) {\n    result = new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Calculates the tile x, y coordinates of the tile containing\n * a given cartographic position.\n *\n * @param {Cartographic} position The position.\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {Cartesian2} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Cartesian2} The specified 'result', or a new object containing the tile x, y coordinates\n *          if 'result' is undefined.\n */\nGeographicTilingScheme.prototype.positionToTileXY = function (\n  position,\n  level,\n  result\n) {\n  const rectangle = this._rectangle;\n  if (!Rectangle.contains(rectangle, position)) {\n    // outside the bounds of the tiling scheme\n    return undefined;\n  }\n\n  const xTiles = this.getNumberOfXTilesAtLevel(level);\n  const yTiles = this.getNumberOfYTilesAtLevel(level);\n\n  const xTileWidth = rectangle.width / xTiles;\n  const yTileHeight = rectangle.height / yTiles;\n\n  let longitude = position.longitude;\n  if (rectangle.east < rectangle.west) {\n    longitude += CesiumMath.TWO_PI;\n  }\n\n  let xTileCoordinate = ((longitude - rectangle.west) / xTileWidth) | 0;\n  if (xTileCoordinate >= xTiles) {\n    xTileCoordinate = xTiles - 1;\n  }\n\n  let yTileCoordinate =\n    ((rectangle.north - position.latitude) / yTileHeight) | 0;\n  if (yTileCoordinate >= yTiles) {\n    yTileCoordinate = yTiles - 1;\n  }\n\n  if (!defined(result)) {\n    return new Cartesian2(xTileCoordinate, yTileCoordinate);\n  }\n\n  result.x = xTileCoordinate;\n  result.y = yTileCoordinate;\n  return result;\n};\nexport default GeographicTilingScheme;\n","import BoundingSphere from \"./BoundingSphere.js\";\nimport buildModuleUrl from \"./buildModuleUrl.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Resource from \"./Resource.js\";\n\nconst scratchDiagonalCartesianNE = new Cartesian3();\nconst scratchDiagonalCartesianSW = new Cartesian3();\nconst scratchDiagonalCartographic = new Cartographic();\nconst scratchCenterCartesian = new Cartesian3();\nconst scratchSurfaceCartesian = new Cartesian3();\n\nconst scratchBoundingSphere = new BoundingSphere();\nconst tilingScheme = new GeographicTilingScheme();\nconst scratchCorners = [\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n];\nconst scratchTileXY = new Cartesian2();\n\n/**\n * A collection of functions for approximating terrain height\n * @private\n */\nconst ApproximateTerrainHeights = {};\n\n/**\n * Initializes the minimum and maximum terrain heights\n * @return {Promise.<void>}\n */\nApproximateTerrainHeights.initialize = function () {\n  let initPromise = ApproximateTerrainHeights._initPromise;\n  if (defined(initPromise)) {\n    return initPromise;\n  }\n\n  initPromise = Resource.fetchJson(\n    buildModuleUrl(\"Assets/approximateTerrainHeights.json\")\n  ).then(function (json) {\n    ApproximateTerrainHeights._terrainHeights = json;\n  });\n  ApproximateTerrainHeights._initPromise = initPromise;\n\n  return initPromise;\n};\n\n/**\n * Computes the minimum and maximum terrain heights for a given rectangle\n * @param {Rectangle} rectangle The bounding rectangle\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid\n * @return {{minimumTerrainHeight: Number, maximumTerrainHeight: Number}}\n */\nApproximateTerrainHeights.getMinimumMaximumHeights = function (\n  rectangle,\n  ellipsoid\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"rectangle\", rectangle);\n  if (!defined(ApproximateTerrainHeights._terrainHeights)) {\n    throw new DeveloperError(\n      \"You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function\"\n    );\n  }\n  //>>includeEnd('debug');\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  const xyLevel = getTileXYLevel(rectangle);\n\n  // Get the terrain min/max for that tile\n  let minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\n  let maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  if (defined(xyLevel)) {\n    const key = `${xyLevel.level}-${xyLevel.x}-${xyLevel.y}`;\n    const heights = ApproximateTerrainHeights._terrainHeights[key];\n    if (defined(heights)) {\n      minTerrainHeight = heights[0];\n      maxTerrainHeight = heights[1];\n    }\n\n    // Compute min by taking the center of the NE->SW diagonal and finding distance to the surface\n    ellipsoid.cartographicToCartesian(\n      Rectangle.northeast(rectangle, scratchDiagonalCartographic),\n      scratchDiagonalCartesianNE\n    );\n    ellipsoid.cartographicToCartesian(\n      Rectangle.southwest(rectangle, scratchDiagonalCartographic),\n      scratchDiagonalCartesianSW\n    );\n\n    Cartesian3.midpoint(\n      scratchDiagonalCartesianSW,\n      scratchDiagonalCartesianNE,\n      scratchCenterCartesian\n    );\n    const surfacePosition = ellipsoid.scaleToGeodeticSurface(\n      scratchCenterCartesian,\n      scratchSurfaceCartesian\n    );\n    if (defined(surfacePosition)) {\n      const distance = Cartesian3.distance(\n        scratchCenterCartesian,\n        surfacePosition\n      );\n      minTerrainHeight = Math.min(minTerrainHeight, -distance);\n    } else {\n      minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\n    }\n  }\n\n  minTerrainHeight = Math.max(\n    ApproximateTerrainHeights._defaultMinTerrainHeight,\n    minTerrainHeight\n  );\n\n  return {\n    minimumTerrainHeight: minTerrainHeight,\n    maximumTerrainHeight: maxTerrainHeight,\n  };\n};\n\n/**\n * Computes the bounding sphere based on the tile heights in the rectangle\n * @param {Rectangle} rectangle The bounding rectangle\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid\n * @return {BoundingSphere} The result bounding sphere\n */\nApproximateTerrainHeights.getBoundingSphere = function (rectangle, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"rectangle\", rectangle);\n  if (!defined(ApproximateTerrainHeights._terrainHeights)) {\n    throw new DeveloperError(\n      \"You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function\"\n    );\n  }\n  //>>includeEnd('debug');\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  const xyLevel = getTileXYLevel(rectangle);\n\n  // Get the terrain max for that tile\n  let maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  if (defined(xyLevel)) {\n    const key = `${xyLevel.level}-${xyLevel.x}-${xyLevel.y}`;\n    const heights = ApproximateTerrainHeights._terrainHeights[key];\n    if (defined(heights)) {\n      maxTerrainHeight = heights[1];\n    }\n  }\n\n  const result = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, 0.0);\n  BoundingSphere.fromRectangle3D(\n    rectangle,\n    ellipsoid,\n    maxTerrainHeight,\n    scratchBoundingSphere\n  );\n\n  return BoundingSphere.union(result, scratchBoundingSphere, result);\n};\n\nfunction getTileXYLevel(rectangle) {\n  Cartographic.fromRadians(\n    rectangle.east,\n    rectangle.north,\n    0.0,\n    scratchCorners[0]\n  );\n  Cartographic.fromRadians(\n    rectangle.west,\n    rectangle.north,\n    0.0,\n    scratchCorners[1]\n  );\n  Cartographic.fromRadians(\n    rectangle.east,\n    rectangle.south,\n    0.0,\n    scratchCorners[2]\n  );\n  Cartographic.fromRadians(\n    rectangle.west,\n    rectangle.south,\n    0.0,\n    scratchCorners[3]\n  );\n\n  // Determine which tile the bounding rectangle is in\n  let lastLevelX = 0,\n    lastLevelY = 0;\n  let currentX = 0,\n    currentY = 0;\n  const maxLevel = ApproximateTerrainHeights._terrainHeightsMaxLevel;\n  let i;\n  for (i = 0; i <= maxLevel; ++i) {\n    let failed = false;\n    for (let j = 0; j < 4; ++j) {\n      const corner = scratchCorners[j];\n      tilingScheme.positionToTileXY(corner, i, scratchTileXY);\n      if (j === 0) {\n        currentX = scratchTileXY.x;\n        currentY = scratchTileXY.y;\n      } else if (currentX !== scratchTileXY.x || currentY !== scratchTileXY.y) {\n        failed = true;\n        break;\n      }\n    }\n\n    if (failed) {\n      break;\n    }\n\n    lastLevelX = currentX;\n    lastLevelY = currentY;\n  }\n\n  if (i === 0) {\n    return undefined;\n  }\n\n  return {\n    x: lastLevelX,\n    y: lastLevelY,\n    level: i > maxLevel ? maxLevel : i - 1,\n  };\n}\n\nApproximateTerrainHeights._terrainHeightsMaxLevel = 6;\nApproximateTerrainHeights._defaultMaxTerrainHeight = 9000.0;\nApproximateTerrainHeights._defaultMinTerrainHeight = -100000.0;\nApproximateTerrainHeights._terrainHeights = undefined;\nApproximateTerrainHeights._initPromise = undefined;\n\nObject.defineProperties(ApproximateTerrainHeights, {\n  /**\n   * Determines if the terrain heights are initialized and ready to use. To initialize the terrain heights,\n   * call {@link ApproximateTerrainHeights#initialize} and wait for the returned promise to resolve.\n   * @type {Boolean}\n   * @readonly\n   * @memberof ApproximateTerrainHeights\n   */\n  initialized: {\n    get: function () {\n      return defined(ApproximateTerrainHeights._terrainHeights);\n    },\n  },\n});\nexport default ApproximateTerrainHeights;\n","import ApproximateTerrainHeights from \"./ApproximateTerrainHeights.js\";\nimport ArcType from \"./ArcType.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport EncodedCartesian3 from \"./EncodedCartesian3.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Plane from \"./Plane.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport WebMercatorProjection from \"./WebMercatorProjection.js\";\n\nconst PROJECTIONS = [GeographicProjection, WebMercatorProjection];\nconst PROJECTION_COUNT = PROJECTIONS.length;\n\nconst MITER_BREAK_SMALL = Math.cos(CesiumMath.toRadians(30.0));\nconst MITER_BREAK_LARGE = Math.cos(CesiumMath.toRadians(150.0));\n\n// Initial heights for constructing the wall.\n// Keeping WALL_INITIAL_MIN_HEIGHT near the ellipsoid surface helps\n// prevent precision problems with planes in the shader.\n// Putting the start point of a plane at ApproximateTerrainHeights._defaultMinTerrainHeight,\n// which is a highly conservative bound, usually puts the plane origin several thousands\n// of meters away from the actual terrain, causing floating point problems when checking\n// fragments on terrain against the plane.\n// Ellipsoid height is generally much closer.\n// The initial max height is arbitrary.\n// Both heights are corrected using ApproximateTerrainHeights for computing the actual volume geometry.\nconst WALL_INITIAL_MIN_HEIGHT = 0.0;\nconst WALL_INITIAL_MAX_HEIGHT = 1000.0;\n\n/**\n * A description of a polyline on terrain or 3D Tiles. Only to be used with {@link GroundPolylinePrimitive}.\n *\n * @alias GroundPolylineGeometry\n * @constructor\n *\n * @param {Object} options Options with the following properties:\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the polyline's points. Heights above the ellipsoid will be ignored.\n * @param {Number} [options.width=1.0] The screen space width in pixels.\n * @param {Number} [options.granularity=9999.0] The distance interval in meters used for interpolating options.points. Defaults to 9999.0 meters. Zero indicates no interpolation.\n * @param {Boolean} [options.loop=false] Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n *\n * @exception {DeveloperError} At least two positions are required.\n *\n * @see GroundPolylinePrimitive\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -112.1340164450331, 36.05494287836128,\n *   -112.08821010582645, 36.097804071380715,\n *   -112.13296079730024, 36.168769146801104\n * ]);\n *\n * const geometry = new Cesium.GroundPolylineGeometry({\n *   positions : positions\n * });\n */\nfunction GroundPolylineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const positions = options.positions;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions) || positions.length < 2) {\n    throw new DeveloperError(\"At least two positions are required.\");\n  }\n  if (\n    defined(options.arcType) &&\n    options.arcType !== ArcType.GEODESIC &&\n    options.arcType !== ArcType.RHUMB\n  ) {\n    throw new DeveloperError(\n      \"Valid options for arcType are ArcType.GEODESIC and ArcType.RHUMB.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The screen space width in pixels.\n   * @type {Number}\n   */\n  this.width = defaultValue(options.width, 1.0); // Doesn't get packed, not necessary for computing geometry.\n\n  this._positions = positions;\n\n  /**\n   * The distance interval used for interpolating options.points. Zero indicates no interpolation.\n   * Default of 9999.0 allows centimeter accuracy with 32 bit floating point.\n   * @type {Boolean}\n   * @default 9999.0\n   */\n  this.granularity = defaultValue(options.granularity, 9999.0);\n\n  /**\n   * Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\n   * If the geometry has two positions this parameter will be ignored.\n   * @type {Boolean}\n   * @default false\n   */\n  this.loop = defaultValue(options.loop, false);\n\n  /**\n   * The type of path the polyline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n   * @type {ArcType}\n   * @default ArcType.GEODESIC\n   */\n  this.arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n\n  this._ellipsoid = Ellipsoid.WGS84;\n\n  // MapProjections can't be packed, so store the index to a known MapProjection.\n  this._projectionIndex = 0;\n  this._workerName = \"createGroundPolylineGeometry\";\n\n  // Used by GroundPolylinePrimitive to signal worker that scenemode is 3D only.\n  this._scene3DOnly = false;\n}\n\nObject.defineProperties(GroundPolylineGeometry.prototype, {\n  /**\n   * The number of elements used to pack the object into an array.\n   * @memberof GroundPolylineGeometry.prototype\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  packedLength: {\n    get: function () {\n      return (\n        1.0 +\n        this._positions.length * 3 +\n        1.0 +\n        1.0 +\n        1.0 +\n        Ellipsoid.packedLength +\n        1.0 +\n        1.0\n      );\n    },\n  },\n});\n\n/**\n * Set the GroundPolylineGeometry's projection and ellipsoid.\n * Used by GroundPolylinePrimitive to signal scene information to the geometry for generating 2D attributes.\n *\n * @param {GroundPolylineGeometry} groundPolylineGeometry GroundPolylinGeometry describing a polyline on terrain or 3D Tiles.\n * @param {Projection} mapProjection A MapProjection used for projecting cartographic coordinates to 2D.\n * @private\n */\nGroundPolylineGeometry.setProjectionAndEllipsoid = function (\n  groundPolylineGeometry,\n  mapProjection\n) {\n  let projectionIndex = 0;\n  for (let i = 0; i < PROJECTION_COUNT; i++) {\n    if (mapProjection instanceof PROJECTIONS[i]) {\n      projectionIndex = i;\n      break;\n    }\n  }\n\n  groundPolylineGeometry._projectionIndex = projectionIndex;\n  groundPolylineGeometry._ellipsoid = mapProjection.ellipsoid;\n};\n\nconst cart3Scratch1 = new Cartesian3();\nconst cart3Scratch2 = new Cartesian3();\nconst cart3Scratch3 = new Cartesian3();\nfunction computeRightNormal(start, end, maxHeight, ellipsoid, result) {\n  const startBottom = getPosition(ellipsoid, start, 0.0, cart3Scratch1);\n  const startTop = getPosition(ellipsoid, start, maxHeight, cart3Scratch2);\n  const endBottom = getPosition(ellipsoid, end, 0.0, cart3Scratch3);\n\n  const up = direction(startTop, startBottom, cart3Scratch2);\n  const forward = direction(endBottom, startBottom, cart3Scratch3);\n\n  Cartesian3.cross(forward, up, result);\n  return Cartesian3.normalize(result, result);\n}\n\nconst interpolatedCartographicScratch = new Cartographic();\nconst interpolatedBottomScratch = new Cartesian3();\nconst interpolatedTopScratch = new Cartesian3();\nconst interpolatedNormalScratch = new Cartesian3();\nfunction interpolateSegment(\n  start,\n  end,\n  minHeight,\n  maxHeight,\n  granularity,\n  arcType,\n  ellipsoid,\n  normalsArray,\n  bottomPositionsArray,\n  topPositionsArray,\n  cartographicsArray\n) {\n  if (granularity === 0.0) {\n    return;\n  }\n\n  let ellipsoidLine;\n  if (arcType === ArcType.GEODESIC) {\n    ellipsoidLine = new EllipsoidGeodesic(start, end, ellipsoid);\n  } else if (arcType === ArcType.RHUMB) {\n    ellipsoidLine = new EllipsoidRhumbLine(start, end, ellipsoid);\n  }\n\n  const surfaceDistance = ellipsoidLine.surfaceDistance;\n  if (surfaceDistance < granularity) {\n    return;\n  }\n\n  // Compute rightwards normal applicable at all interpolated points\n  const interpolatedNormal = computeRightNormal(\n    start,\n    end,\n    maxHeight,\n    ellipsoid,\n    interpolatedNormalScratch\n  );\n\n  const segments = Math.ceil(surfaceDistance / granularity);\n  const interpointDistance = surfaceDistance / segments;\n  let distanceFromStart = interpointDistance;\n  const pointsToAdd = segments - 1;\n  let packIndex = normalsArray.length;\n  for (let i = 0; i < pointsToAdd; i++) {\n    const interpolatedCartographic = ellipsoidLine.interpolateUsingSurfaceDistance(\n      distanceFromStart,\n      interpolatedCartographicScratch\n    );\n    const interpolatedBottom = getPosition(\n      ellipsoid,\n      interpolatedCartographic,\n      minHeight,\n      interpolatedBottomScratch\n    );\n    const interpolatedTop = getPosition(\n      ellipsoid,\n      interpolatedCartographic,\n      maxHeight,\n      interpolatedTopScratch\n    );\n\n    Cartesian3.pack(interpolatedNormal, normalsArray, packIndex);\n    Cartesian3.pack(interpolatedBottom, bottomPositionsArray, packIndex);\n    Cartesian3.pack(interpolatedTop, topPositionsArray, packIndex);\n    cartographicsArray.push(interpolatedCartographic.latitude);\n    cartographicsArray.push(interpolatedCartographic.longitude);\n\n    packIndex += 3;\n    distanceFromStart += interpointDistance;\n  }\n}\n\nconst heightlessCartographicScratch = new Cartographic();\nfunction getPosition(ellipsoid, cartographic, height, result) {\n  Cartographic.clone(cartographic, heightlessCartographicScratch);\n  heightlessCartographicScratch.height = height;\n  return Cartographic.toCartesian(\n    heightlessCartographicScratch,\n    ellipsoid,\n    result\n  );\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolygonGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nGroundPolylineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  let index = defaultValue(startingIndex, 0);\n\n  const positions = value._positions;\n  const positionsLength = positions.length;\n\n  array[index++] = positionsLength;\n\n  for (let i = 0; i < positionsLength; ++i) {\n    const cartesian = positions[i];\n    Cartesian3.pack(cartesian, array, index);\n    index += 3;\n  }\n\n  array[index++] = value.granularity;\n  array[index++] = value.loop ? 1.0 : 0.0;\n  array[index++] = value.arcType;\n\n  Ellipsoid.pack(value._ellipsoid, array, index);\n  index += Ellipsoid.packedLength;\n\n  array[index++] = value._projectionIndex;\n  array[index++] = value._scene3DOnly ? 1.0 : 0.0;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolygonGeometry} [result] The object into which to store the result.\n */\nGroundPolylineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  let index = defaultValue(startingIndex, 0);\n  const positionsLength = array[index++];\n  const positions = new Array(positionsLength);\n\n  for (let i = 0; i < positionsLength; i++) {\n    positions[i] = Cartesian3.unpack(array, index);\n    index += 3;\n  }\n\n  const granularity = array[index++];\n  const loop = array[index++] === 1.0;\n  const arcType = array[index++];\n\n  const ellipsoid = Ellipsoid.unpack(array, index);\n  index += Ellipsoid.packedLength;\n\n  const projectionIndex = array[index++];\n  const scene3DOnly = array[index++] === 1.0;\n\n  if (!defined(result)) {\n    result = new GroundPolylineGeometry({\n      positions: positions,\n    });\n  }\n\n  result._positions = positions;\n  result.granularity = granularity;\n  result.loop = loop;\n  result.arcType = arcType;\n  result._ellipsoid = ellipsoid;\n  result._projectionIndex = projectionIndex;\n  result._scene3DOnly = scene3DOnly;\n\n  return result;\n};\n\nfunction direction(target, origin, result) {\n  Cartesian3.subtract(target, origin, result);\n  Cartesian3.normalize(result, result);\n  return result;\n}\n\nfunction tangentDirection(target, origin, up, result) {\n  result = direction(target, origin, result);\n\n  // orthogonalize\n  result = Cartesian3.cross(result, up, result);\n  result = Cartesian3.normalize(result, result);\n  result = Cartesian3.cross(up, result, result);\n  return result;\n}\n\nconst toPreviousScratch = new Cartesian3();\nconst toNextScratch = new Cartesian3();\nconst forwardScratch = new Cartesian3();\nconst vertexUpScratch = new Cartesian3();\nconst cosine90 = 0.0;\nconst cosine180 = -1.0;\nfunction computeVertexMiterNormal(\n  previousBottom,\n  vertexBottom,\n  vertexTop,\n  nextBottom,\n  result\n) {\n  const up = direction(vertexTop, vertexBottom, vertexUpScratch);\n\n  // Compute vectors pointing towards neighboring points but tangent to this point on the ellipsoid\n  const toPrevious = tangentDirection(\n    previousBottom,\n    vertexBottom,\n    up,\n    toPreviousScratch\n  );\n  const toNext = tangentDirection(nextBottom, vertexBottom, up, toNextScratch);\n\n  // Check if tangents are almost opposite - if so, no need to miter.\n  if (\n    CesiumMath.equalsEpsilon(\n      Cartesian3.dot(toPrevious, toNext),\n      cosine180,\n      CesiumMath.EPSILON5\n    )\n  ) {\n    result = Cartesian3.cross(up, toPrevious, result);\n    result = Cartesian3.normalize(result, result);\n    return result;\n  }\n\n  // Average directions to previous and to next in the plane of Up\n  result = Cartesian3.add(toNext, toPrevious, result);\n  result = Cartesian3.normalize(result, result);\n\n  // Flip the normal if it isn't pointing roughly bound right (aka if forward is pointing more \"backwards\")\n  const forward = Cartesian3.cross(up, result, forwardScratch);\n  if (Cartesian3.dot(toNext, forward) < cosine90) {\n    result = Cartesian3.negate(result, result);\n  }\n\n  return result;\n}\n\nconst XZ_PLANE = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\n\nconst previousBottomScratch = new Cartesian3();\nconst vertexBottomScratch = new Cartesian3();\nconst vertexTopScratch = new Cartesian3();\nconst nextBottomScratch = new Cartesian3();\nconst vertexNormalScratch = new Cartesian3();\nconst intersectionScratch = new Cartesian3();\nconst cartographicScratch0 = new Cartographic();\nconst cartographicScratch1 = new Cartographic();\nconst cartographicIntersectionScratch = new Cartographic();\n/**\n * Computes shadow volumes for the ground polyline, consisting of its vertices, indices, and a bounding sphere.\n * Vertices are \"fat,\" packing all the data needed in each volume to describe a line on terrain or 3D Tiles.\n * Should not be called independent of {@link GroundPolylinePrimitive}.\n *\n * @param {GroundPolylineGeometry} groundPolylineGeometry\n * @private\n */\nGroundPolylineGeometry.createGeometry = function (groundPolylineGeometry) {\n  const compute2dAttributes = !groundPolylineGeometry._scene3DOnly;\n  let loop = groundPolylineGeometry.loop;\n  const ellipsoid = groundPolylineGeometry._ellipsoid;\n  const granularity = groundPolylineGeometry.granularity;\n  const arcType = groundPolylineGeometry.arcType;\n  const projection = new PROJECTIONS[groundPolylineGeometry._projectionIndex](\n    ellipsoid\n  );\n\n  const minHeight = WALL_INITIAL_MIN_HEIGHT;\n  const maxHeight = WALL_INITIAL_MAX_HEIGHT;\n\n  let index;\n  let i;\n\n  const positions = groundPolylineGeometry._positions;\n  const positionsLength = positions.length;\n\n  if (positionsLength === 2) {\n    loop = false;\n  }\n\n  // Split positions across the IDL and the Prime Meridian as well.\n  // Split across prime meridian because very large geometries crossing the Prime Meridian but not the IDL\n  // may get split by the plane of IDL + Prime Meridian.\n  let p0;\n  let p1;\n  let c0;\n  let c1;\n  const rhumbLine = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  let intersection;\n  let intersectionCartographic;\n  let intersectionLongitude;\n  const splitPositions = [positions[0]];\n  for (i = 0; i < positionsLength - 1; i++) {\n    p0 = positions[i];\n    p1 = positions[i + 1];\n    intersection = IntersectionTests.lineSegmentPlane(\n      p0,\n      p1,\n      XZ_PLANE,\n      intersectionScratch\n    );\n    if (\n      defined(intersection) &&\n      !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n      !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n    ) {\n      if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\n        splitPositions.push(Cartesian3.clone(intersection));\n      } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\n        intersectionLongitude = ellipsoid.cartesianToCartographic(\n          intersection,\n          cartographicScratch0\n        ).longitude;\n        c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\n        c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\n        rhumbLine.setEndPoints(c0, c1);\n        intersectionCartographic = rhumbLine.findIntersectionWithLongitude(\n          intersectionLongitude,\n          cartographicIntersectionScratch\n        );\n        intersection = ellipsoid.cartographicToCartesian(\n          intersectionCartographic,\n          intersectionScratch\n        );\n        if (\n          defined(intersection) &&\n          !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n          !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n        ) {\n          splitPositions.push(Cartesian3.clone(intersection));\n        }\n      }\n    }\n    splitPositions.push(p1);\n  }\n\n  if (loop) {\n    p0 = positions[positionsLength - 1];\n    p1 = positions[0];\n    intersection = IntersectionTests.lineSegmentPlane(\n      p0,\n      p1,\n      XZ_PLANE,\n      intersectionScratch\n    );\n    if (\n      defined(intersection) &&\n      !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n      !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n    ) {\n      if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\n        splitPositions.push(Cartesian3.clone(intersection));\n      } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\n        intersectionLongitude = ellipsoid.cartesianToCartographic(\n          intersection,\n          cartographicScratch0\n        ).longitude;\n        c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\n        c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\n        rhumbLine.setEndPoints(c0, c1);\n        intersectionCartographic = rhumbLine.findIntersectionWithLongitude(\n          intersectionLongitude,\n          cartographicIntersectionScratch\n        );\n        intersection = ellipsoid.cartographicToCartesian(\n          intersectionCartographic,\n          intersectionScratch\n        );\n        if (\n          defined(intersection) &&\n          !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n          !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n        ) {\n          splitPositions.push(Cartesian3.clone(intersection));\n        }\n      }\n    }\n  }\n  let cartographicsLength = splitPositions.length;\n\n  let cartographics = new Array(cartographicsLength);\n  for (i = 0; i < cartographicsLength; i++) {\n    const cartographic = Cartographic.fromCartesian(\n      splitPositions[i],\n      ellipsoid\n    );\n    cartographic.height = 0.0;\n    cartographics[i] = cartographic;\n  }\n\n  cartographics = arrayRemoveDuplicates(\n    cartographics,\n    Cartographic.equalsEpsilon\n  );\n  cartographicsLength = cartographics.length;\n\n  if (cartographicsLength < 2) {\n    return undefined;\n  }\n\n  /**** Build heap-side arrays for positions, interpolated cartographics, and normals from which to compute vertices ****/\n  // We build a \"wall\" and then decompose it into separately connected component \"volumes\" because we need a lot\n  // of information about the wall. Also, this simplifies interpolation.\n  // Convention: \"next\" and \"end\" are locally forward to each segment of the wall,\n  // and we are computing normals pointing towards the local right side of the vertices in each segment.\n  const cartographicsArray = [];\n  const normalsArray = [];\n  const bottomPositionsArray = [];\n  const topPositionsArray = [];\n\n  let previousBottom = previousBottomScratch;\n  let vertexBottom = vertexBottomScratch;\n  let vertexTop = vertexTopScratch;\n  let nextBottom = nextBottomScratch;\n  let vertexNormal = vertexNormalScratch;\n\n  // First point - either loop or attach a \"perpendicular\" normal\n  const startCartographic = cartographics[0];\n  const nextCartographic = cartographics[1];\n\n  const prestartCartographic = cartographics[cartographicsLength - 1];\n  previousBottom = getPosition(\n    ellipsoid,\n    prestartCartographic,\n    minHeight,\n    previousBottom\n  );\n  nextBottom = getPosition(ellipsoid, nextCartographic, minHeight, nextBottom);\n  vertexBottom = getPosition(\n    ellipsoid,\n    startCartographic,\n    minHeight,\n    vertexBottom\n  );\n  vertexTop = getPosition(ellipsoid, startCartographic, maxHeight, vertexTop);\n\n  if (loop) {\n    vertexNormal = computeVertexMiterNormal(\n      previousBottom,\n      vertexBottom,\n      vertexTop,\n      nextBottom,\n      vertexNormal\n    );\n  } else {\n    vertexNormal = computeRightNormal(\n      startCartographic,\n      nextCartographic,\n      maxHeight,\n      ellipsoid,\n      vertexNormal\n    );\n  }\n\n  Cartesian3.pack(vertexNormal, normalsArray, 0);\n  Cartesian3.pack(vertexBottom, bottomPositionsArray, 0);\n  Cartesian3.pack(vertexTop, topPositionsArray, 0);\n  cartographicsArray.push(startCartographic.latitude);\n  cartographicsArray.push(startCartographic.longitude);\n\n  interpolateSegment(\n    startCartographic,\n    nextCartographic,\n    minHeight,\n    maxHeight,\n    granularity,\n    arcType,\n    ellipsoid,\n    normalsArray,\n    bottomPositionsArray,\n    topPositionsArray,\n    cartographicsArray\n  );\n\n  // All inbetween points\n  for (i = 1; i < cartographicsLength - 1; ++i) {\n    previousBottom = Cartesian3.clone(vertexBottom, previousBottom);\n    vertexBottom = Cartesian3.clone(nextBottom, vertexBottom);\n    const vertexCartographic = cartographics[i];\n    getPosition(ellipsoid, vertexCartographic, maxHeight, vertexTop);\n    getPosition(ellipsoid, cartographics[i + 1], minHeight, nextBottom);\n\n    computeVertexMiterNormal(\n      previousBottom,\n      vertexBottom,\n      vertexTop,\n      nextBottom,\n      vertexNormal\n    );\n\n    index = normalsArray.length;\n    Cartesian3.pack(vertexNormal, normalsArray, index);\n    Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\n    Cartesian3.pack(vertexTop, topPositionsArray, index);\n    cartographicsArray.push(vertexCartographic.latitude);\n    cartographicsArray.push(vertexCartographic.longitude);\n\n    interpolateSegment(\n      cartographics[i],\n      cartographics[i + 1],\n      minHeight,\n      maxHeight,\n      granularity,\n      arcType,\n      ellipsoid,\n      normalsArray,\n      bottomPositionsArray,\n      topPositionsArray,\n      cartographicsArray\n    );\n  }\n\n  // Last point - either loop or attach a normal \"perpendicular\" to the wall.\n  const endCartographic = cartographics[cartographicsLength - 1];\n  const preEndCartographic = cartographics[cartographicsLength - 2];\n\n  vertexBottom = getPosition(\n    ellipsoid,\n    endCartographic,\n    minHeight,\n    vertexBottom\n  );\n  vertexTop = getPosition(ellipsoid, endCartographic, maxHeight, vertexTop);\n\n  if (loop) {\n    const postEndCartographic = cartographics[0];\n    previousBottom = getPosition(\n      ellipsoid,\n      preEndCartographic,\n      minHeight,\n      previousBottom\n    );\n    nextBottom = getPosition(\n      ellipsoid,\n      postEndCartographic,\n      minHeight,\n      nextBottom\n    );\n\n    vertexNormal = computeVertexMiterNormal(\n      previousBottom,\n      vertexBottom,\n      vertexTop,\n      nextBottom,\n      vertexNormal\n    );\n  } else {\n    vertexNormal = computeRightNormal(\n      preEndCartographic,\n      endCartographic,\n      maxHeight,\n      ellipsoid,\n      vertexNormal\n    );\n  }\n\n  index = normalsArray.length;\n  Cartesian3.pack(vertexNormal, normalsArray, index);\n  Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\n  Cartesian3.pack(vertexTop, topPositionsArray, index);\n  cartographicsArray.push(endCartographic.latitude);\n  cartographicsArray.push(endCartographic.longitude);\n\n  if (loop) {\n    interpolateSegment(\n      endCartographic,\n      startCartographic,\n      minHeight,\n      maxHeight,\n      granularity,\n      arcType,\n      ellipsoid,\n      normalsArray,\n      bottomPositionsArray,\n      topPositionsArray,\n      cartographicsArray\n    );\n    index = normalsArray.length;\n    for (i = 0; i < 3; ++i) {\n      normalsArray[index + i] = normalsArray[i];\n      bottomPositionsArray[index + i] = bottomPositionsArray[i];\n      topPositionsArray[index + i] = topPositionsArray[i];\n    }\n    cartographicsArray.push(startCartographic.latitude);\n    cartographicsArray.push(startCartographic.longitude);\n  }\n\n  return generateGeometryAttributes(\n    loop,\n    projection,\n    bottomPositionsArray,\n    topPositionsArray,\n    normalsArray,\n    cartographicsArray,\n    compute2dAttributes\n  );\n};\n\n// If the end normal angle is too steep compared to the direction of the line segment,\n// \"break\" the miter by rotating the normal 90 degrees around the \"up\" direction at the point\n// For ultra precision we would want to project into a plane, but in practice this is sufficient.\nconst lineDirectionScratch = new Cartesian3();\nconst matrix3Scratch = new Matrix3();\nconst quaternionScratch = new Quaternion();\nfunction breakMiter(endGeometryNormal, startBottom, endBottom, endTop) {\n  const lineDirection = direction(endBottom, startBottom, lineDirectionScratch);\n\n  const dot = Cartesian3.dot(lineDirection, endGeometryNormal);\n  if (dot > MITER_BREAK_SMALL || dot < MITER_BREAK_LARGE) {\n    const vertexUp = direction(endTop, endBottom, vertexUpScratch);\n    const angle =\n      dot < MITER_BREAK_LARGE\n        ? CesiumMath.PI_OVER_TWO\n        : -CesiumMath.PI_OVER_TWO;\n    const quaternion = Quaternion.fromAxisAngle(\n      vertexUp,\n      angle,\n      quaternionScratch\n    );\n    const rotationMatrix = Matrix3.fromQuaternion(quaternion, matrix3Scratch);\n    Matrix3.multiplyByVector(\n      rotationMatrix,\n      endGeometryNormal,\n      endGeometryNormal\n    );\n    return true;\n  }\n  return false;\n}\n\nconst endPosCartographicScratch = new Cartographic();\nconst normalStartpointScratch = new Cartesian3();\nconst normalEndpointScratch = new Cartesian3();\nfunction projectNormal(\n  projection,\n  cartographic,\n  normal,\n  projectedPosition,\n  result\n) {\n  const position = Cartographic.toCartesian(\n    cartographic,\n    projection._ellipsoid,\n    normalStartpointScratch\n  );\n  let normalEndpoint = Cartesian3.add(position, normal, normalEndpointScratch);\n  let flipNormal = false;\n\n  const ellipsoid = projection._ellipsoid;\n  let normalEndpointCartographic = ellipsoid.cartesianToCartographic(\n    normalEndpoint,\n    endPosCartographicScratch\n  );\n  // If normal crosses the IDL, go the other way and flip the result.\n  // In practice this almost never happens because the cartographic start\n  // and end points of each segment are \"nudged\" to be on the same side\n  // of the IDL and slightly away from the IDL.\n  if (\n    Math.abs(cartographic.longitude - normalEndpointCartographic.longitude) >\n    CesiumMath.PI_OVER_TWO\n  ) {\n    flipNormal = true;\n    normalEndpoint = Cartesian3.subtract(\n      position,\n      normal,\n      normalEndpointScratch\n    );\n    normalEndpointCartographic = ellipsoid.cartesianToCartographic(\n      normalEndpoint,\n      endPosCartographicScratch\n    );\n  }\n\n  normalEndpointCartographic.height = 0.0;\n  const normalEndpointProjected = projection.project(\n    normalEndpointCartographic,\n    result\n  );\n  result = Cartesian3.subtract(\n    normalEndpointProjected,\n    projectedPosition,\n    result\n  );\n  result.z = 0.0;\n  result = Cartesian3.normalize(result, result);\n  if (flipNormal) {\n    Cartesian3.negate(result, result);\n  }\n  return result;\n}\n\nconst adjustHeightNormalScratch = new Cartesian3();\nconst adjustHeightOffsetScratch = new Cartesian3();\nfunction adjustHeights(\n  bottom,\n  top,\n  minHeight,\n  maxHeight,\n  adjustHeightBottom,\n  adjustHeightTop\n) {\n  // bottom and top should be at WALL_INITIAL_MIN_HEIGHT and WALL_INITIAL_MAX_HEIGHT, respectively\n  const adjustHeightNormal = Cartesian3.subtract(\n    top,\n    bottom,\n    adjustHeightNormalScratch\n  );\n  Cartesian3.normalize(adjustHeightNormal, adjustHeightNormal);\n\n  const distanceForBottom = minHeight - WALL_INITIAL_MIN_HEIGHT;\n  let adjustHeightOffset = Cartesian3.multiplyByScalar(\n    adjustHeightNormal,\n    distanceForBottom,\n    adjustHeightOffsetScratch\n  );\n  Cartesian3.add(bottom, adjustHeightOffset, adjustHeightBottom);\n\n  const distanceForTop = maxHeight - WALL_INITIAL_MAX_HEIGHT;\n  adjustHeightOffset = Cartesian3.multiplyByScalar(\n    adjustHeightNormal,\n    distanceForTop,\n    adjustHeightOffsetScratch\n  );\n  Cartesian3.add(top, adjustHeightOffset, adjustHeightTop);\n}\n\nconst nudgeDirectionScratch = new Cartesian3();\nfunction nudgeXZ(start, end) {\n  const startToXZdistance = Plane.getPointDistance(XZ_PLANE, start);\n  const endToXZdistance = Plane.getPointDistance(XZ_PLANE, end);\n  let offset = nudgeDirectionScratch;\n  // Larger epsilon than what's used in GeometryPipeline, a centimeter in world space\n  if (CesiumMath.equalsEpsilon(startToXZdistance, 0.0, CesiumMath.EPSILON2)) {\n    offset = direction(end, start, offset);\n    Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\n    Cartesian3.add(start, offset, start);\n  } else if (\n    CesiumMath.equalsEpsilon(endToXZdistance, 0.0, CesiumMath.EPSILON2)\n  ) {\n    offset = direction(start, end, offset);\n    Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\n    Cartesian3.add(end, offset, end);\n  }\n}\n\n// \"Nudge\" cartographic coordinates so start and end are on the same side of the IDL.\n// Nudge amounts are tiny, basically just an IDL flip.\n// Only used for 2D/CV.\nfunction nudgeCartographic(start, end) {\n  const absStartLon = Math.abs(start.longitude);\n  const absEndLon = Math.abs(end.longitude);\n  if (\n    CesiumMath.equalsEpsilon(absStartLon, CesiumMath.PI, CesiumMath.EPSILON11)\n  ) {\n    const endSign = CesiumMath.sign(end.longitude);\n    start.longitude = endSign * (absStartLon - CesiumMath.EPSILON11);\n    return 1;\n  } else if (\n    CesiumMath.equalsEpsilon(absEndLon, CesiumMath.PI, CesiumMath.EPSILON11)\n  ) {\n    const startSign = CesiumMath.sign(start.longitude);\n    end.longitude = startSign * (absEndLon - CesiumMath.EPSILON11);\n    return 2;\n  }\n  return 0;\n}\n\nconst startCartographicScratch = new Cartographic();\nconst endCartographicScratch = new Cartographic();\n\nconst segmentStartTopScratch = new Cartesian3();\nconst segmentEndTopScratch = new Cartesian3();\nconst segmentStartBottomScratch = new Cartesian3();\nconst segmentEndBottomScratch = new Cartesian3();\nconst segmentStartNormalScratch = new Cartesian3();\nconst segmentEndNormalScratch = new Cartesian3();\n\nconst getHeightCartographics = [\n  startCartographicScratch,\n  endCartographicScratch,\n];\nconst getHeightRectangleScratch = new Rectangle();\n\nconst adjustHeightStartTopScratch = new Cartesian3();\nconst adjustHeightEndTopScratch = new Cartesian3();\nconst adjustHeightStartBottomScratch = new Cartesian3();\nconst adjustHeightEndBottomScratch = new Cartesian3();\n\nconst segmentStart2DScratch = new Cartesian3();\nconst segmentEnd2DScratch = new Cartesian3();\nconst segmentStartNormal2DScratch = new Cartesian3();\nconst segmentEndNormal2DScratch = new Cartesian3();\n\nconst offsetScratch = new Cartesian3();\nconst startUpScratch = new Cartesian3();\nconst endUpScratch = new Cartesian3();\nconst rightScratch = new Cartesian3();\nconst startPlaneNormalScratch = new Cartesian3();\nconst endPlaneNormalScratch = new Cartesian3();\nconst encodeScratch = new EncodedCartesian3();\n\nconst encodeScratch2D = new EncodedCartesian3();\nconst forwardOffset2DScratch = new Cartesian3();\nconst right2DScratch = new Cartesian3();\n\nconst normalNudgeScratch = new Cartesian3();\n\nconst scratchBoundingSpheres = [new BoundingSphere(), new BoundingSphere()];\n\n// Winding order is reversed so each segment's volume is inside-out\nconst REFERENCE_INDICES = [\n  0,\n  2,\n  1,\n  0,\n  3,\n  2, // right\n  0,\n  7,\n  3,\n  0,\n  4,\n  7, // start\n  0,\n  5,\n  4,\n  0,\n  1,\n  5, // bottom\n  5,\n  7,\n  4,\n  5,\n  6,\n  7, // left\n  5,\n  2,\n  6,\n  5,\n  1,\n  2, // end\n  3,\n  6,\n  2,\n  3,\n  7,\n  6, // top\n];\nconst REFERENCE_INDICES_LENGTH = REFERENCE_INDICES.length;\n\n// Decompose the \"wall\" into a series of shadow volumes.\n// Each shadow volume's vertices encode a description of the line it contains,\n// including mitering planes at the end points, a plane along the line itself,\n// and attributes for computing length-wise texture coordinates.\nfunction generateGeometryAttributes(\n  loop,\n  projection,\n  bottomPositionsArray,\n  topPositionsArray,\n  normalsArray,\n  cartographicsArray,\n  compute2dAttributes\n) {\n  let i;\n  let index;\n  const ellipsoid = projection._ellipsoid;\n\n  // Each segment will have 8 vertices\n  const segmentCount = bottomPositionsArray.length / 3 - 1;\n  const vertexCount = segmentCount * 8;\n  const arraySizeVec4 = vertexCount * 4;\n  const indexCount = segmentCount * 36;\n\n  const indices =\n    vertexCount > 65535\n      ? new Uint32Array(indexCount)\n      : new Uint16Array(indexCount);\n  const positionsArray = new Float64Array(vertexCount * 3);\n\n  const startHiAndForwardOffsetX = new Float32Array(arraySizeVec4);\n  const startLoAndForwardOffsetY = new Float32Array(arraySizeVec4);\n  const startNormalAndForwardOffsetZ = new Float32Array(arraySizeVec4);\n  const endNormalAndTextureCoordinateNormalizationX = new Float32Array(\n    arraySizeVec4\n  );\n  const rightNormalAndTextureCoordinateNormalizationY = new Float32Array(\n    arraySizeVec4\n  );\n\n  let startHiLo2D;\n  let offsetAndRight2D;\n  let startEndNormals2D;\n  let texcoordNormalization2D;\n\n  if (compute2dAttributes) {\n    startHiLo2D = new Float32Array(arraySizeVec4);\n    offsetAndRight2D = new Float32Array(arraySizeVec4);\n    startEndNormals2D = new Float32Array(arraySizeVec4);\n    texcoordNormalization2D = new Float32Array(vertexCount * 2);\n  }\n\n  /*** Compute total lengths for texture coordinate normalization ***/\n  // 2D\n  const cartographicsLength = cartographicsArray.length / 2;\n  let length2D = 0.0;\n\n  const startCartographic = startCartographicScratch;\n  startCartographic.height = 0.0;\n  const endCartographic = endCartographicScratch;\n  endCartographic.height = 0.0;\n\n  let segmentStartCartesian = segmentStartTopScratch;\n  let segmentEndCartesian = segmentEndTopScratch;\n\n  if (compute2dAttributes) {\n    index = 0;\n    for (i = 1; i < cartographicsLength; i++) {\n      // Don't clone anything from previous segment b/c possible IDL touch\n      startCartographic.latitude = cartographicsArray[index];\n      startCartographic.longitude = cartographicsArray[index + 1];\n      endCartographic.latitude = cartographicsArray[index + 2];\n      endCartographic.longitude = cartographicsArray[index + 3];\n\n      segmentStartCartesian = projection.project(\n        startCartographic,\n        segmentStartCartesian\n      );\n      segmentEndCartesian = projection.project(\n        endCartographic,\n        segmentEndCartesian\n      );\n      length2D += Cartesian3.distance(\n        segmentStartCartesian,\n        segmentEndCartesian\n      );\n      index += 2;\n    }\n  }\n\n  // 3D\n  const positionsLength = topPositionsArray.length / 3;\n  segmentEndCartesian = Cartesian3.unpack(\n    topPositionsArray,\n    0,\n    segmentEndCartesian\n  );\n  let length3D = 0.0;\n\n  index = 3;\n  for (i = 1; i < positionsLength; i++) {\n    segmentStartCartesian = Cartesian3.clone(\n      segmentEndCartesian,\n      segmentStartCartesian\n    );\n    segmentEndCartesian = Cartesian3.unpack(\n      topPositionsArray,\n      index,\n      segmentEndCartesian\n    );\n    length3D += Cartesian3.distance(segmentStartCartesian, segmentEndCartesian);\n    index += 3;\n  }\n\n  /*** Generate segments ***/\n  let j;\n  index = 3;\n  let cartographicsIndex = 0;\n  let vec2sWriteIndex = 0;\n  let vec3sWriteIndex = 0;\n  let vec4sWriteIndex = 0;\n  let miterBroken = false;\n\n  let endBottom = Cartesian3.unpack(\n    bottomPositionsArray,\n    0,\n    segmentEndBottomScratch\n  );\n  let endTop = Cartesian3.unpack(topPositionsArray, 0, segmentEndTopScratch);\n  let endGeometryNormal = Cartesian3.unpack(\n    normalsArray,\n    0,\n    segmentEndNormalScratch\n  );\n\n  if (loop) {\n    const preEndBottom = Cartesian3.unpack(\n      bottomPositionsArray,\n      bottomPositionsArray.length - 6,\n      segmentStartBottomScratch\n    );\n    if (breakMiter(endGeometryNormal, preEndBottom, endBottom, endTop)) {\n      // Miter broken as if for the last point in the loop, needs to be inverted for first point (clone of endBottom)\n      endGeometryNormal = Cartesian3.negate(\n        endGeometryNormal,\n        endGeometryNormal\n      );\n    }\n  }\n\n  let lengthSoFar3D = 0.0;\n  let lengthSoFar2D = 0.0;\n\n  // For translating bounding volume\n  let sumHeights = 0.0;\n\n  for (i = 0; i < segmentCount; i++) {\n    const startBottom = Cartesian3.clone(endBottom, segmentStartBottomScratch);\n    const startTop = Cartesian3.clone(endTop, segmentStartTopScratch);\n    let startGeometryNormal = Cartesian3.clone(\n      endGeometryNormal,\n      segmentStartNormalScratch\n    );\n\n    if (miterBroken) {\n      startGeometryNormal = Cartesian3.negate(\n        startGeometryNormal,\n        startGeometryNormal\n      );\n    }\n\n    endBottom = Cartesian3.unpack(\n      bottomPositionsArray,\n      index,\n      segmentEndBottomScratch\n    );\n    endTop = Cartesian3.unpack(topPositionsArray, index, segmentEndTopScratch);\n    endGeometryNormal = Cartesian3.unpack(\n      normalsArray,\n      index,\n      segmentEndNormalScratch\n    );\n\n    miterBroken = breakMiter(endGeometryNormal, startBottom, endBottom, endTop);\n\n    // 2D - don't clone anything from previous segment b/c possible IDL touch\n    startCartographic.latitude = cartographicsArray[cartographicsIndex];\n    startCartographic.longitude = cartographicsArray[cartographicsIndex + 1];\n    endCartographic.latitude = cartographicsArray[cartographicsIndex + 2];\n    endCartographic.longitude = cartographicsArray[cartographicsIndex + 3];\n    let start2D;\n    let end2D;\n    let startGeometryNormal2D;\n    let endGeometryNormal2D;\n\n    if (compute2dAttributes) {\n      const nudgeResult = nudgeCartographic(startCartographic, endCartographic);\n      start2D = projection.project(startCartographic, segmentStart2DScratch);\n      end2D = projection.project(endCartographic, segmentEnd2DScratch);\n      const direction2D = direction(end2D, start2D, forwardOffset2DScratch);\n      direction2D.y = Math.abs(direction2D.y);\n\n      startGeometryNormal2D = segmentStartNormal2DScratch;\n      endGeometryNormal2D = segmentEndNormal2DScratch;\n      if (\n        nudgeResult === 0 ||\n        Cartesian3.dot(direction2D, Cartesian3.UNIT_Y) > MITER_BREAK_SMALL\n      ) {\n        // No nudge - project the original normal\n        // Or, if the line's angle relative to the IDL is very acute,\n        // in which case snapping will produce oddly shaped volumes.\n        startGeometryNormal2D = projectNormal(\n          projection,\n          startCartographic,\n          startGeometryNormal,\n          start2D,\n          segmentStartNormal2DScratch\n        );\n        endGeometryNormal2D = projectNormal(\n          projection,\n          endCartographic,\n          endGeometryNormal,\n          end2D,\n          segmentEndNormal2DScratch\n        );\n      } else if (nudgeResult === 1) {\n        // Start is close to IDL - snap start normal to align with IDL\n        endGeometryNormal2D = projectNormal(\n          projection,\n          endCartographic,\n          endGeometryNormal,\n          end2D,\n          segmentEndNormal2DScratch\n        );\n        startGeometryNormal2D.x = 0.0;\n        // If start longitude is negative and end longitude is less negative, relative right is unit -Y\n        // If start longitude is positive and end longitude is less positive, relative right is unit +Y\n        startGeometryNormal2D.y = CesiumMath.sign(\n          startCartographic.longitude - Math.abs(endCartographic.longitude)\n        );\n        startGeometryNormal2D.z = 0.0;\n      } else {\n        // End is close to IDL - snap end normal to align with IDL\n        startGeometryNormal2D = projectNormal(\n          projection,\n          startCartographic,\n          startGeometryNormal,\n          start2D,\n          segmentStartNormal2DScratch\n        );\n        endGeometryNormal2D.x = 0.0;\n        // If end longitude is negative and start longitude is less negative, relative right is unit Y\n        // If end longitude is positive and start longitude is less positive, relative right is unit -Y\n        endGeometryNormal2D.y = CesiumMath.sign(\n          startCartographic.longitude - endCartographic.longitude\n        );\n        endGeometryNormal2D.z = 0.0;\n      }\n    }\n\n    /****************************************\n     * Geometry descriptors of a \"line on terrain,\"\n     * as opposed to the \"shadow volume used to draw\n     * the line on terrain\":\n     * - position of start + offset to end\n     * - start, end, and right-facing planes\n     * - encoded texture coordinate offsets\n     ****************************************/\n\n    /* 3D */\n    const segmentLength3D = Cartesian3.distance(startTop, endTop);\n\n    const encodedStart = EncodedCartesian3.fromCartesian(\n      startBottom,\n      encodeScratch\n    );\n    const forwardOffset = Cartesian3.subtract(\n      endBottom,\n      startBottom,\n      offsetScratch\n    );\n    const forward = Cartesian3.normalize(forwardOffset, rightScratch);\n\n    let startUp = Cartesian3.subtract(startTop, startBottom, startUpScratch);\n    startUp = Cartesian3.normalize(startUp, startUp);\n    let rightNormal = Cartesian3.cross(forward, startUp, rightScratch);\n    rightNormal = Cartesian3.normalize(rightNormal, rightNormal);\n\n    let startPlaneNormal = Cartesian3.cross(\n      startUp,\n      startGeometryNormal,\n      startPlaneNormalScratch\n    );\n    startPlaneNormal = Cartesian3.normalize(startPlaneNormal, startPlaneNormal);\n\n    let endUp = Cartesian3.subtract(endTop, endBottom, endUpScratch);\n    endUp = Cartesian3.normalize(endUp, endUp);\n    let endPlaneNormal = Cartesian3.cross(\n      endGeometryNormal,\n      endUp,\n      endPlaneNormalScratch\n    );\n    endPlaneNormal = Cartesian3.normalize(endPlaneNormal, endPlaneNormal);\n\n    const texcoordNormalization3DX = segmentLength3D / length3D;\n    const texcoordNormalization3DY = lengthSoFar3D / length3D;\n\n    /* 2D */\n    let segmentLength2D = 0.0;\n    let encodedStart2D;\n    let forwardOffset2D;\n    let right2D;\n    let texcoordNormalization2DX = 0.0;\n    let texcoordNormalization2DY = 0.0;\n    if (compute2dAttributes) {\n      segmentLength2D = Cartesian3.distance(start2D, end2D);\n\n      encodedStart2D = EncodedCartesian3.fromCartesian(\n        start2D,\n        encodeScratch2D\n      );\n      forwardOffset2D = Cartesian3.subtract(\n        end2D,\n        start2D,\n        forwardOffset2DScratch\n      );\n\n      // Right direction is just forward direction rotated by -90 degrees around Z\n      // Similarly with plane normals\n      right2D = Cartesian3.normalize(forwardOffset2D, right2DScratch);\n      const swap = right2D.x;\n      right2D.x = right2D.y;\n      right2D.y = -swap;\n\n      texcoordNormalization2DX = segmentLength2D / length2D;\n      texcoordNormalization2DY = lengthSoFar2D / length2D;\n    }\n    /** Pack **/\n    for (j = 0; j < 8; j++) {\n      const vec4Index = vec4sWriteIndex + j * 4;\n      const vec2Index = vec2sWriteIndex + j * 2;\n      const wIndex = vec4Index + 3;\n\n      // Encode sidedness of vertex relative to right plane in texture coordinate normalization X,\n      // whether vertex is top or bottom of volume in sign/magnitude of normalization Y.\n      const rightPlaneSide = j < 4 ? 1.0 : -1.0;\n      const topBottomSide =\n        j === 2 || j === 3 || j === 6 || j === 7 ? 1.0 : -1.0;\n\n      // 3D\n      Cartesian3.pack(encodedStart.high, startHiAndForwardOffsetX, vec4Index);\n      startHiAndForwardOffsetX[wIndex] = forwardOffset.x;\n\n      Cartesian3.pack(encodedStart.low, startLoAndForwardOffsetY, vec4Index);\n      startLoAndForwardOffsetY[wIndex] = forwardOffset.y;\n\n      Cartesian3.pack(\n        startPlaneNormal,\n        startNormalAndForwardOffsetZ,\n        vec4Index\n      );\n      startNormalAndForwardOffsetZ[wIndex] = forwardOffset.z;\n\n      Cartesian3.pack(\n        endPlaneNormal,\n        endNormalAndTextureCoordinateNormalizationX,\n        vec4Index\n      );\n      endNormalAndTextureCoordinateNormalizationX[wIndex] =\n        texcoordNormalization3DX * rightPlaneSide;\n\n      Cartesian3.pack(\n        rightNormal,\n        rightNormalAndTextureCoordinateNormalizationY,\n        vec4Index\n      );\n\n      let texcoordNormalization = texcoordNormalization3DY * topBottomSide;\n      if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\n        texcoordNormalization = 9.0; // some value greater than 1.0\n      }\n      rightNormalAndTextureCoordinateNormalizationY[\n        wIndex\n      ] = texcoordNormalization;\n\n      // 2D\n      if (compute2dAttributes) {\n        startHiLo2D[vec4Index] = encodedStart2D.high.x;\n        startHiLo2D[vec4Index + 1] = encodedStart2D.high.y;\n        startHiLo2D[vec4Index + 2] = encodedStart2D.low.x;\n        startHiLo2D[vec4Index + 3] = encodedStart2D.low.y;\n\n        startEndNormals2D[vec4Index] = -startGeometryNormal2D.y;\n        startEndNormals2D[vec4Index + 1] = startGeometryNormal2D.x;\n        startEndNormals2D[vec4Index + 2] = endGeometryNormal2D.y;\n        startEndNormals2D[vec4Index + 3] = -endGeometryNormal2D.x;\n\n        offsetAndRight2D[vec4Index] = forwardOffset2D.x;\n        offsetAndRight2D[vec4Index + 1] = forwardOffset2D.y;\n        offsetAndRight2D[vec4Index + 2] = right2D.x;\n        offsetAndRight2D[vec4Index + 3] = right2D.y;\n\n        texcoordNormalization2D[vec2Index] =\n          texcoordNormalization2DX * rightPlaneSide;\n\n        texcoordNormalization = texcoordNormalization2DY * topBottomSide;\n        if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\n          texcoordNormalization = 9.0; // some value greater than 1.0\n        }\n        texcoordNormalization2D[vec2Index + 1] = texcoordNormalization;\n      }\n    }\n\n    // Adjust height of volume in 3D\n    const adjustHeightStartBottom = adjustHeightStartBottomScratch;\n    const adjustHeightEndBottom = adjustHeightEndBottomScratch;\n    const adjustHeightStartTop = adjustHeightStartTopScratch;\n    const adjustHeightEndTop = adjustHeightEndTopScratch;\n\n    const getHeightsRectangle = Rectangle.fromCartographicArray(\n      getHeightCartographics,\n      getHeightRectangleScratch\n    );\n    const minMaxHeights = ApproximateTerrainHeights.getMinimumMaximumHeights(\n      getHeightsRectangle,\n      ellipsoid\n    );\n    const minHeight = minMaxHeights.minimumTerrainHeight;\n    const maxHeight = minMaxHeights.maximumTerrainHeight;\n\n    sumHeights += minHeight;\n    sumHeights += maxHeight;\n\n    adjustHeights(\n      startBottom,\n      startTop,\n      minHeight,\n      maxHeight,\n      adjustHeightStartBottom,\n      adjustHeightStartTop\n    );\n    adjustHeights(\n      endBottom,\n      endTop,\n      minHeight,\n      maxHeight,\n      adjustHeightEndBottom,\n      adjustHeightEndTop\n    );\n\n    // Nudge the positions away from the \"polyline\" a little bit to prevent errors in GeometryPipeline\n    let normalNudge = Cartesian3.multiplyByScalar(\n      rightNormal,\n      CesiumMath.EPSILON5,\n      normalNudgeScratch\n    );\n    Cartesian3.add(\n      adjustHeightStartBottom,\n      normalNudge,\n      adjustHeightStartBottom\n    );\n    Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\n    Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\n    Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\n\n    // If the segment is very close to the XZ plane, nudge the vertices slightly to avoid touching it.\n    nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\n    nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\n\n    Cartesian3.pack(adjustHeightStartBottom, positionsArray, vec3sWriteIndex);\n    Cartesian3.pack(adjustHeightEndBottom, positionsArray, vec3sWriteIndex + 3);\n    Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 6);\n    Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 9);\n\n    normalNudge = Cartesian3.multiplyByScalar(\n      rightNormal,\n      -2.0 * CesiumMath.EPSILON5,\n      normalNudgeScratch\n    );\n    Cartesian3.add(\n      adjustHeightStartBottom,\n      normalNudge,\n      adjustHeightStartBottom\n    );\n    Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\n    Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\n    Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\n\n    nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\n    nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\n\n    Cartesian3.pack(\n      adjustHeightStartBottom,\n      positionsArray,\n      vec3sWriteIndex + 12\n    );\n    Cartesian3.pack(\n      adjustHeightEndBottom,\n      positionsArray,\n      vec3sWriteIndex + 15\n    );\n    Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 18);\n    Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 21);\n\n    cartographicsIndex += 2;\n    index += 3;\n\n    vec2sWriteIndex += 16;\n    vec3sWriteIndex += 24;\n    vec4sWriteIndex += 32;\n\n    lengthSoFar3D += segmentLength3D;\n    lengthSoFar2D += segmentLength2D;\n  }\n\n  index = 0;\n  let indexOffset = 0;\n  for (i = 0; i < segmentCount; i++) {\n    for (j = 0; j < REFERENCE_INDICES_LENGTH; j++) {\n      indices[index + j] = REFERENCE_INDICES[j] + indexOffset;\n    }\n    indexOffset += 8;\n    index += REFERENCE_INDICES_LENGTH;\n  }\n\n  const boundingSpheres = scratchBoundingSpheres;\n  BoundingSphere.fromVertices(\n    bottomPositionsArray,\n    Cartesian3.ZERO,\n    3,\n    boundingSpheres[0]\n  );\n  BoundingSphere.fromVertices(\n    topPositionsArray,\n    Cartesian3.ZERO,\n    3,\n    boundingSpheres[1]\n  );\n  const boundingSphere = BoundingSphere.fromBoundingSpheres(boundingSpheres);\n\n  // Adjust bounding sphere height and radius to cover more of the volume\n  boundingSphere.radius += sumHeights / (segmentCount * 2.0);\n\n  const attributes = {\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      normalize: false,\n      values: positionsArray,\n    }),\n    startHiAndForwardOffsetX: getVec4GeometryAttribute(\n      startHiAndForwardOffsetX\n    ),\n    startLoAndForwardOffsetY: getVec4GeometryAttribute(\n      startLoAndForwardOffsetY\n    ),\n    startNormalAndForwardOffsetZ: getVec4GeometryAttribute(\n      startNormalAndForwardOffsetZ\n    ),\n    endNormalAndTextureCoordinateNormalizationX: getVec4GeometryAttribute(\n      endNormalAndTextureCoordinateNormalizationX\n    ),\n    rightNormalAndTextureCoordinateNormalizationY: getVec4GeometryAttribute(\n      rightNormalAndTextureCoordinateNormalizationY\n    ),\n  };\n\n  if (compute2dAttributes) {\n    attributes.startHiLo2D = getVec4GeometryAttribute(startHiLo2D);\n    attributes.offsetAndRight2D = getVec4GeometryAttribute(offsetAndRight2D);\n    attributes.startEndNormals2D = getVec4GeometryAttribute(startEndNormals2D);\n    attributes.texcoordNormalization2D = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      normalize: false,\n      values: texcoordNormalization2D,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    boundingSphere: boundingSphere,\n  });\n}\n\nfunction getVec4GeometryAttribute(typedArray) {\n  return new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    values: typedArray,\n  });\n}\n\n/**\n * Approximates an ellipsoid-tangent vector in 2D by projecting the end point into 2D.\n * Exposed for testing.\n *\n * @param {MapProjection} projection Map Projection for projecting coordinates to 2D.\n * @param {Cartographic} cartographic The cartographic origin point of the normal.\n *   Used to check if the normal crosses the IDL during projection.\n * @param {Cartesian3} normal The normal in 3D.\n * @param {Cartesian3} projectedPosition The projected origin point of the normal in 2D.\n * @param {Cartesian3} result Result parameter on which to store the projected normal.\n * @private\n */\nGroundPolylineGeometry._projectNormal = projectNormal;\nexport default GroundPolylineGeometry;\n","import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport defined from \"../Core/defined.js\";\nimport GroundPolylineGeometry from \"../Core/GroundPolylineGeometry.js\";\n\nfunction createGroundPolylineGeometry(groundPolylineGeometry, offset) {\n  return ApproximateTerrainHeights.initialize().then(function () {\n    if (defined(offset)) {\n      groundPolylineGeometry = GroundPolylineGeometry.unpack(\n        groundPolylineGeometry,\n        offset\n      );\n    }\n    return GroundPolylineGeometry.createGeometry(groundPolylineGeometry);\n  });\n}\nexport default createGroundPolylineGeometry;\n"],"names":["defaultValue","Ellipsoid","Rectangle","GeographicProjection","Check","CesiumMath","defined","Cartesian2","Cartesian3","Cartographic","BoundingSphere","Resource","buildModuleUrl","DeveloperError","WebMercatorProjection","ArcType","EllipsoidGeodesic","EllipsoidRhumbLine","Plane","IntersectionTests","arrayRemoveDuplicates","Matrix3","Quaternion","EncodedCartesian3","GeometryAttribute","ComponentDatatype","Geometry"],"mappings":"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"}