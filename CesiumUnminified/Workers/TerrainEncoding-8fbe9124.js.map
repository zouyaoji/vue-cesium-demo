{"version":3,"file":"TerrainEncoding-8fbe9124.js","sources":["../../../../Source/Core/EllipsoidalOccluder.js","../../../../Source/Core/TerrainExaggeration.js","../../../../Source/Core/TerrainQuantization.js","../../../../Source/Core/TerrainEncoding.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * Determine whether or not other objects are visible or hidden behind the visible horizon defined by\n * an {@link Ellipsoid} and a camera position.  The ellipsoid is assumed to be located at the\n * origin of the coordinate system.  This class uses the algorithm described in the\n * {@link https://cesium.com/blog/2013/04/25/Horizon-culling/|Horizon Culling} blog post.\n *\n * @alias EllipsoidalOccluder\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to use as an occluder.\n * @param {Cartesian3} [cameraPosition] The coordinate of the viewer/camera.  If this parameter is not\n *        specified, {@link EllipsoidalOccluder#cameraPosition} must be called before\n *        testing visibility.\n *\n * @constructor\n *\n * @example\n * // Construct an ellipsoidal occluder with radii 1.0, 1.1, and 0.9.\n * const cameraPosition = new Cesium.Cartesian3(5.0, 6.0, 7.0);\n * const occluderEllipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * const occluder = new Cesium.EllipsoidalOccluder(occluderEllipsoid, cameraPosition);\n *\n * @private\n */\nfunction EllipsoidalOccluder(ellipsoid, cameraPosition) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  //>>includeEnd('debug');\n\n  this._ellipsoid = ellipsoid;\n  this._cameraPosition = new Cartesian3();\n  this._cameraPositionInScaledSpace = new Cartesian3();\n  this._distanceToLimbInScaledSpaceSquared = 0.0;\n\n  // cameraPosition fills in the above values\n  if (defined(cameraPosition)) {\n    this.cameraPosition = cameraPosition;\n  }\n}\n\nObject.defineProperties(EllipsoidalOccluder.prototype, {\n  /**\n   * Gets the occluding ellipsoid.\n   * @memberof EllipsoidalOccluder.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n  /**\n   * Gets or sets the position of the camera.\n   * @memberof EllipsoidalOccluder.prototype\n   * @type {Cartesian3}\n   */\n  cameraPosition: {\n    get: function () {\n      return this._cameraPosition;\n    },\n    set: function (cameraPosition) {\n      // See https://cesium.com/blog/2013/04/25/Horizon-culling/\n      const ellipsoid = this._ellipsoid;\n      const cv = ellipsoid.transformPositionToScaledSpace(\n        cameraPosition,\n        this._cameraPositionInScaledSpace\n      );\n      const vhMagnitudeSquared = Cartesian3.magnitudeSquared(cv) - 1.0;\n\n      Cartesian3.clone(cameraPosition, this._cameraPosition);\n      this._cameraPositionInScaledSpace = cv;\n      this._distanceToLimbInScaledSpaceSquared = vhMagnitudeSquared;\n    },\n  },\n});\n\nconst scratchCartesian = new Cartesian3();\n\n/**\n * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.\n *\n * @param {Cartesian3} occludee The point to test for visibility.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n * @example\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n * const ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * const occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n * const point = new Cesium.Cartesian3(0, -3, -3);\n * occluder.isPointVisible(point); //returns true\n */\nEllipsoidalOccluder.prototype.isPointVisible = function (occludee) {\n  const ellipsoid = this._ellipsoid;\n  const occludeeScaledSpacePosition = ellipsoid.transformPositionToScaledSpace(\n    occludee,\n    scratchCartesian\n  );\n  return isScaledSpacePointVisible(\n    occludeeScaledSpacePosition,\n    this._cameraPositionInScaledSpace,\n    this._distanceToLimbInScaledSpaceSquared\n  );\n};\n\n/**\n * Determines whether or not a point expressed in the ellipsoid scaled space, is hidden from view by the\n * occluder.  To transform a Cartesian X, Y, Z position in the coordinate system aligned with the ellipsoid\n * into the scaled space, call {@link Ellipsoid#transformPositionToScaledSpace}.\n *\n * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n * @example\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n * const ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * const occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n * const point = new Cesium.Cartesian3(0, -3, -3);\n * const scaledSpacePoint = ellipsoid.transformPositionToScaledSpace(point);\n * occluder.isScaledSpacePointVisible(scaledSpacePoint); //returns true\n */\nEllipsoidalOccluder.prototype.isScaledSpacePointVisible = function (\n  occludeeScaledSpacePosition\n) {\n  return isScaledSpacePointVisible(\n    occludeeScaledSpacePosition,\n    this._cameraPositionInScaledSpace,\n    this._distanceToLimbInScaledSpaceSquared\n  );\n};\n\nconst scratchCameraPositionInScaledSpaceShrunk = new Cartesian3();\n\n/**\n * Similar to {@link EllipsoidalOccluder#isScaledSpacePointVisible} except tests against an\n * ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. This is intended to be used with points generated by\n * {@link EllipsoidalOccluder#computeHorizonCullingPointPossiblyUnderEllipsoid} or\n * {@link EllipsoidalOccluder#computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space of the possibly-shrunk ellipsoid.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n */\nEllipsoidalOccluder.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid = function (\n  occludeeScaledSpacePosition,\n  minimumHeight\n) {\n  const ellipsoid = this._ellipsoid;\n  let vhMagnitudeSquared;\n  let cv;\n\n  if (\n    defined(minimumHeight) &&\n    minimumHeight < 0.0 &&\n    ellipsoid.minimumRadius > -minimumHeight\n  ) {\n    // This code is similar to the cameraPosition setter, but unrolled for performance because it will be called a lot.\n    cv = scratchCameraPositionInScaledSpaceShrunk;\n    cv.x = this._cameraPosition.x / (ellipsoid.radii.x + minimumHeight);\n    cv.y = this._cameraPosition.y / (ellipsoid.radii.y + minimumHeight);\n    cv.z = this._cameraPosition.z / (ellipsoid.radii.z + minimumHeight);\n    vhMagnitudeSquared = cv.x * cv.x + cv.y * cv.y + cv.z * cv.z - 1.0;\n  } else {\n    cv = this._cameraPositionInScaledSpace;\n    vhMagnitudeSquared = this._distanceToLimbInScaledSpaceSquared;\n  }\n\n  return isScaledSpacePointVisible(\n    occludeeScaledSpacePosition,\n    cv,\n    vhMagnitudeSquared\n  );\n};\n\n/**\n * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\n * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\n * is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\n *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                       ellipsoid's axes.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPoint = function (\n  directionToPoint,\n  positions,\n  result\n) {\n  return computeHorizonCullingPointFromPositions(\n    this._ellipsoid,\n    directionToPoint,\n    positions,\n    result\n  );\n};\n\nconst scratchEllipsoidShrunk = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n\n/**\n * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPoint} except computes the culling\n * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\n * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\n *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                       ellipsoid's axes.\n * @param {Number} [minimumHeight] The minimum height of all positions. If this value is undefined, all positions are assumed to be above the ellipsoid.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid = function (\n  directionToPoint,\n  positions,\n  minimumHeight,\n  result\n) {\n  const possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(\n    this._ellipsoid,\n    minimumHeight,\n    scratchEllipsoidShrunk\n  );\n  return computeHorizonCullingPointFromPositions(\n    possiblyShrunkEllipsoid,\n    directionToPoint,\n    positions,\n    result\n  );\n};\n/**\n * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\n * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\n * is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\n *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                   ellipsoid's axes.\n * @param {Number} [stride=3]\n * @param {Cartesian3} [center=Cartesian3.ZERO]\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromVertices = function (\n  directionToPoint,\n  vertices,\n  stride,\n  center,\n  result\n) {\n  return computeHorizonCullingPointFromVertices(\n    this._ellipsoid,\n    directionToPoint,\n    vertices,\n    stride,\n    center,\n    result\n  );\n};\n\n/**\n * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPointFromVertices} except computes the culling\n * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\n * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\n *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                   ellipsoid's axes.\n * @param {Number} [stride=3]\n * @param {Cartesian3} [center=Cartesian3.ZERO]\n * @param {Number} [minimumHeight] The minimum height of all vertices. If this value is undefined, all vertices are assumed to be above the ellipsoid.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid = function (\n  directionToPoint,\n  vertices,\n  stride,\n  center,\n  minimumHeight,\n  result\n) {\n  const possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(\n    this._ellipsoid,\n    minimumHeight,\n    scratchEllipsoidShrunk\n  );\n  return computeHorizonCullingPointFromVertices(\n    possiblyShrunkEllipsoid,\n    directionToPoint,\n    vertices,\n    stride,\n    center,\n    result\n  );\n};\n\nconst subsampleScratch = [];\n\n/**\n * Computes a point that can be used for horizon culling of a rectangle.  If the point is below\n * the horizon, the ellipsoid-conforming rectangle is guaranteed to be below the horizon as well.\n * The returned point is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Rectangle} rectangle The rectangle for which to compute the horizon culling point.\n * @param {Ellipsoid} ellipsoid The ellipsoid on which the rectangle is defined.  This may be different from\n *                    the ellipsoid used by this instance for occlusion testing.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromRectangle = function (\n  rectangle,\n  ellipsoid,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  const positions = Rectangle.subsample(\n    rectangle,\n    ellipsoid,\n    0.0,\n    subsampleScratch\n  );\n  const bs = BoundingSphere.fromPoints(positions);\n\n  // If the bounding sphere center is too close to the center of the occluder, it doesn't make\n  // sense to try to horizon cull it.\n  if (Cartesian3.magnitude(bs.center) < 0.1 * ellipsoid.minimumRadius) {\n    return undefined;\n  }\n\n  return this.computeHorizonCullingPoint(bs.center, positions, result);\n};\n\nconst scratchEllipsoidShrunkRadii = new Cartesian3();\n\nfunction getPossiblyShrunkEllipsoid(ellipsoid, minimumHeight, result) {\n  if (\n    defined(minimumHeight) &&\n    minimumHeight < 0.0 &&\n    ellipsoid.minimumRadius > -minimumHeight\n  ) {\n    const ellipsoidShrunkRadii = Cartesian3.fromElements(\n      ellipsoid.radii.x + minimumHeight,\n      ellipsoid.radii.y + minimumHeight,\n      ellipsoid.radii.z + minimumHeight,\n      scratchEllipsoidShrunkRadii\n    );\n    ellipsoid = Ellipsoid.fromCartesian3(ellipsoidShrunkRadii, result);\n  }\n  return ellipsoid;\n}\n\nfunction computeHorizonCullingPointFromPositions(\n  ellipsoid,\n  directionToPoint,\n  positions,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"directionToPoint\", directionToPoint);\n  Check.defined(\"positions\", positions);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  const scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(\n    ellipsoid,\n    directionToPoint\n  );\n  let resultMagnitude = 0.0;\n\n  for (let i = 0, len = positions.length; i < len; ++i) {\n    const position = positions[i];\n    const candidateMagnitude = computeMagnitude(\n      ellipsoid,\n      position,\n      scaledSpaceDirectionToPoint\n    );\n    if (candidateMagnitude < 0.0) {\n      // all points should face the same direction, but this one doesn't, so return undefined\n      return undefined;\n    }\n    resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\n  }\n\n  return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\n}\n\nconst positionScratch = new Cartesian3();\n\nfunction computeHorizonCullingPointFromVertices(\n  ellipsoid,\n  directionToPoint,\n  vertices,\n  stride,\n  center,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"directionToPoint\", directionToPoint);\n  Check.defined(\"vertices\", vertices);\n  Check.typeOf.number(\"stride\", stride);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  stride = defaultValue(stride, 3);\n  center = defaultValue(center, Cartesian3.ZERO);\n  const scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(\n    ellipsoid,\n    directionToPoint\n  );\n  let resultMagnitude = 0.0;\n\n  for (let i = 0, len = vertices.length; i < len; i += stride) {\n    positionScratch.x = vertices[i] + center.x;\n    positionScratch.y = vertices[i + 1] + center.y;\n    positionScratch.z = vertices[i + 2] + center.z;\n\n    const candidateMagnitude = computeMagnitude(\n      ellipsoid,\n      positionScratch,\n      scaledSpaceDirectionToPoint\n    );\n    if (candidateMagnitude < 0.0) {\n      // all points should face the same direction, but this one doesn't, so return undefined\n      return undefined;\n    }\n    resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\n  }\n\n  return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\n}\n\nfunction isScaledSpacePointVisible(\n  occludeeScaledSpacePosition,\n  cameraPositionInScaledSpace,\n  distanceToLimbInScaledSpaceSquared\n) {\n  // See https://cesium.com/blog/2013/04/25/Horizon-culling/\n  const cv = cameraPositionInScaledSpace;\n  const vhMagnitudeSquared = distanceToLimbInScaledSpaceSquared;\n  const vt = Cartesian3.subtract(\n    occludeeScaledSpacePosition,\n    cv,\n    scratchCartesian\n  );\n  const vtDotVc = -Cartesian3.dot(vt, cv);\n  // If vhMagnitudeSquared < 0 then we are below the surface of the ellipsoid and\n  // in this case, set the culling plane to be on V.\n  const isOccluded =\n    vhMagnitudeSquared < 0\n      ? vtDotVc > 0\n      : vtDotVc > vhMagnitudeSquared &&\n        (vtDotVc * vtDotVc) / Cartesian3.magnitudeSquared(vt) >\n          vhMagnitudeSquared;\n  return !isOccluded;\n}\n\nconst scaledSpaceScratch = new Cartesian3();\nconst directionScratch = new Cartesian3();\n\nfunction computeMagnitude(ellipsoid, position, scaledSpaceDirectionToPoint) {\n  const scaledSpacePosition = ellipsoid.transformPositionToScaledSpace(\n    position,\n    scaledSpaceScratch\n  );\n  let magnitudeSquared = Cartesian3.magnitudeSquared(scaledSpacePosition);\n  let magnitude = Math.sqrt(magnitudeSquared);\n  const direction = Cartesian3.divideByScalar(\n    scaledSpacePosition,\n    magnitude,\n    directionScratch\n  );\n\n  // For the purpose of this computation, points below the ellipsoid are consider to be on it instead.\n  magnitudeSquared = Math.max(1.0, magnitudeSquared);\n  magnitude = Math.max(1.0, magnitude);\n\n  const cosAlpha = Cartesian3.dot(direction, scaledSpaceDirectionToPoint);\n  const sinAlpha = Cartesian3.magnitude(\n    Cartesian3.cross(direction, scaledSpaceDirectionToPoint, direction)\n  );\n  const cosBeta = 1.0 / magnitude;\n  const sinBeta = Math.sqrt(magnitudeSquared - 1.0) * cosBeta;\n\n  return 1.0 / (cosAlpha * cosBeta - sinAlpha * sinBeta);\n}\n\nfunction magnitudeToPoint(\n  scaledSpaceDirectionToPoint,\n  resultMagnitude,\n  result\n) {\n  // The horizon culling point is undefined if there were no positions from which to compute it,\n  // the directionToPoint is pointing opposite all of the positions,  or if we computed NaN or infinity.\n  if (\n    resultMagnitude <= 0.0 ||\n    resultMagnitude === 1.0 / 0.0 ||\n    resultMagnitude !== resultMagnitude\n  ) {\n    return undefined;\n  }\n\n  return Cartesian3.multiplyByScalar(\n    scaledSpaceDirectionToPoint,\n    resultMagnitude,\n    result\n  );\n}\n\nconst directionToPointScratch = new Cartesian3();\n\nfunction computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint) {\n  if (Cartesian3.equals(directionToPoint, Cartesian3.ZERO)) {\n    return directionToPoint;\n  }\n\n  ellipsoid.transformPositionToScaledSpace(\n    directionToPoint,\n    directionToPointScratch\n  );\n  return Cartesian3.normalize(directionToPointScratch, directionToPointScratch);\n}\nexport default EllipsoidalOccluder;\n","import Cartesian3 from \"./Cartesian3.js\";\n\n/**\n * @private\n */\nconst TerrainExaggeration = {};\n\n/**\n * Scales a height relative to an offset.\n *\n * @param {Number} height The height.\n * @param {Number} scale A scalar used to exaggerate the terrain. If the value is 1.0 there will be no effect.\n * @param {Number} relativeHeight The height relative to which terrain is exaggerated. If the value is 0.0 terrain will be exaggerated relative to the ellipsoid surface.\n */\nTerrainExaggeration.getHeight = function (height, scale, relativeHeight) {\n  return (height - relativeHeight) * scale + relativeHeight;\n};\n\nconst scratchCartographic = new Cartesian3();\n\n/**\n * Scales a position by exaggeration.\n */\nTerrainExaggeration.getPosition = function (\n  position,\n  ellipsoid,\n  terrainExaggeration,\n  terrainExaggerationRelativeHeight,\n  result\n) {\n  const cartographic = ellipsoid.cartesianToCartographic(\n    position,\n    scratchCartographic\n  );\n  const newHeight = TerrainExaggeration.getHeight(\n    cartographic.height,\n    terrainExaggeration,\n    terrainExaggerationRelativeHeight\n  );\n  return Cartesian3.fromRadians(\n    cartographic.longitude,\n    cartographic.latitude,\n    newHeight,\n    ellipsoid,\n    result\n  );\n};\n\nexport default TerrainExaggeration;\n","/**\n * This enumerated type is used to determine how the vertices of the terrain mesh are compressed.\n *\n * @enum {Number}\n *\n * @private\n */\nconst TerrainQuantization = {\n  /**\n   * The vertices are not compressed.\n   *\n   * @type {Number}\n   * @constant\n   */\n  NONE: 0,\n\n  /**\n   * The vertices are compressed to 12 bits.\n   *\n   * @type {Number}\n   * @constant\n   */\n  BITS12: 1,\n};\nexport default Object.freeze(TerrainQuantization);\n","import AttributeCompression from \"./AttributeCompression.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport TerrainExaggeration from \"./TerrainExaggeration.js\";\nimport TerrainQuantization from \"./TerrainQuantization.js\";\n\nconst cartesian3Scratch = new Cartesian3();\nconst cartesian3DimScratch = new Cartesian3();\nconst cartesian2Scratch = new Cartesian2();\nconst matrix4Scratch = new Matrix4();\nconst matrix4Scratch2 = new Matrix4();\n\nconst SHIFT_LEFT_12 = Math.pow(2.0, 12.0);\n\n/**\n * Data used to quantize and pack the terrain mesh. The position can be unpacked for picking and all attributes\n * are unpacked in the vertex shader.\n *\n * @alias TerrainEncoding\n * @constructor\n *\n * @param {Cartesian3} center The center point of the vertices.\n * @param {AxisAlignedBoundingBox} axisAlignedBoundingBox The bounds of the tile in the east-north-up coordinates at the tiles center.\n * @param {Number} minimumHeight The minimum height.\n * @param {Number} maximumHeight The maximum height.\n * @param {Matrix4} fromENU The east-north-up to fixed frame matrix at the center of the terrain mesh.\n * @param {Boolean} hasVertexNormals If the mesh has vertex normals.\n * @param {Boolean} [hasWebMercatorT=false] true if the terrain data includes a Web Mercator texture coordinate; otherwise, false.\n * @param {Boolean} [hasGeodeticSurfaceNormals=false] true if the terrain data includes geodetic surface normals; otherwise, false.\n * @param {Number} [exaggeration=1.0] A scalar used to exaggerate terrain.\n * @param {Number} [exaggerationRelativeHeight=0.0] The relative height from which terrain is exaggerated.\n *\n * @private\n */\nfunction TerrainEncoding(\n  center,\n  axisAlignedBoundingBox,\n  minimumHeight,\n  maximumHeight,\n  fromENU,\n  hasVertexNormals,\n  hasWebMercatorT,\n  hasGeodeticSurfaceNormals,\n  exaggeration,\n  exaggerationRelativeHeight\n) {\n  let quantization = TerrainQuantization.NONE;\n  let toENU;\n  let matrix;\n\n  if (\n    defined(axisAlignedBoundingBox) &&\n    defined(minimumHeight) &&\n    defined(maximumHeight) &&\n    defined(fromENU)\n  ) {\n    const minimum = axisAlignedBoundingBox.minimum;\n    const maximum = axisAlignedBoundingBox.maximum;\n\n    const dimensions = Cartesian3.subtract(\n      maximum,\n      minimum,\n      cartesian3DimScratch\n    );\n    const hDim = maximumHeight - minimumHeight;\n    const maxDim = Math.max(Cartesian3.maximumComponent(dimensions), hDim);\n\n    if (maxDim < SHIFT_LEFT_12 - 1.0) {\n      quantization = TerrainQuantization.BITS12;\n    } else {\n      quantization = TerrainQuantization.NONE;\n    }\n\n    toENU = Matrix4.inverseTransformation(fromENU, new Matrix4());\n\n    const translation = Cartesian3.negate(minimum, cartesian3Scratch);\n    Matrix4.multiply(\n      Matrix4.fromTranslation(translation, matrix4Scratch),\n      toENU,\n      toENU\n    );\n\n    const scale = cartesian3Scratch;\n    scale.x = 1.0 / dimensions.x;\n    scale.y = 1.0 / dimensions.y;\n    scale.z = 1.0 / dimensions.z;\n    Matrix4.multiply(Matrix4.fromScale(scale, matrix4Scratch), toENU, toENU);\n\n    matrix = Matrix4.clone(fromENU);\n    Matrix4.setTranslation(matrix, Cartesian3.ZERO, matrix);\n\n    fromENU = Matrix4.clone(fromENU, new Matrix4());\n\n    const translationMatrix = Matrix4.fromTranslation(minimum, matrix4Scratch);\n    const scaleMatrix = Matrix4.fromScale(dimensions, matrix4Scratch2);\n    const st = Matrix4.multiply(translationMatrix, scaleMatrix, matrix4Scratch);\n\n    Matrix4.multiply(fromENU, st, fromENU);\n    Matrix4.multiply(matrix, st, matrix);\n  }\n\n  /**\n   * How the vertices of the mesh were compressed.\n   * @type {TerrainQuantization}\n   */\n  this.quantization = quantization;\n\n  /**\n   * The minimum height of the tile including the skirts.\n   * @type {Number}\n   */\n  this.minimumHeight = minimumHeight;\n\n  /**\n   * The maximum height of the tile.\n   * @type {Number}\n   */\n  this.maximumHeight = maximumHeight;\n\n  /**\n   * The center of the tile.\n   * @type {Cartesian3}\n   */\n  this.center = Cartesian3.clone(center);\n\n  /**\n   * A matrix that takes a vertex from the tile, transforms it to east-north-up at the center and scales\n   * it so each component is in the [0, 1] range.\n   * @type {Matrix4}\n   */\n  this.toScaledENU = toENU;\n\n  /**\n   * A matrix that restores a vertex transformed with toScaledENU back to the earth fixed reference frame\n   * @type {Matrix4}\n   */\n  this.fromScaledENU = fromENU;\n\n  /**\n   * The matrix used to decompress the terrain vertices in the shader for RTE rendering.\n   * @type {Matrix4}\n   */\n  this.matrix = matrix;\n\n  /**\n   * The terrain mesh contains normals.\n   * @type {Boolean}\n   */\n  this.hasVertexNormals = hasVertexNormals;\n\n  /**\n   * The terrain mesh contains a vertical texture coordinate following the Web Mercator projection.\n   * @type {Boolean}\n   */\n  this.hasWebMercatorT = defaultValue(hasWebMercatorT, false);\n\n  /**\n   * The terrain mesh contains geodetic surface normals, used for terrain exaggeration.\n   * @type {Boolean}\n   */\n  this.hasGeodeticSurfaceNormals = defaultValue(\n    hasGeodeticSurfaceNormals,\n    false\n  );\n\n  /**\n   * A scalar used to exaggerate terrain.\n   * @type {Number}\n   */\n  this.exaggeration = defaultValue(exaggeration, 1.0);\n\n  /**\n   * The relative height from which terrain is exaggerated.\n   */\n  this.exaggerationRelativeHeight = defaultValue(\n    exaggerationRelativeHeight,\n    0.0\n  );\n\n  /**\n   * The number of components in each vertex. This value can differ with different quantizations.\n   * @type {Number}\n   */\n  this.stride = 0;\n\n  this._offsetGeodeticSurfaceNormal = 0;\n  this._offsetVertexNormal = 0;\n\n  // Calculate the stride and offsets declared above\n  this._calculateStrideAndOffsets();\n}\n\nTerrainEncoding.prototype.encode = function (\n  vertexBuffer,\n  bufferIndex,\n  position,\n  uv,\n  height,\n  normalToPack,\n  webMercatorT,\n  geodeticSurfaceNormal\n) {\n  const u = uv.x;\n  const v = uv.y;\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    position = Matrix4.multiplyByPoint(\n      this.toScaledENU,\n      position,\n      cartesian3Scratch\n    );\n\n    position.x = CesiumMath.clamp(position.x, 0.0, 1.0);\n    position.y = CesiumMath.clamp(position.y, 0.0, 1.0);\n    position.z = CesiumMath.clamp(position.z, 0.0, 1.0);\n\n    const hDim = this.maximumHeight - this.minimumHeight;\n    const h = CesiumMath.clamp((height - this.minimumHeight) / hDim, 0.0, 1.0);\n\n    Cartesian2.fromElements(position.x, position.y, cartesian2Scratch);\n    const compressed0 = AttributeCompression.compressTextureCoordinates(\n      cartesian2Scratch\n    );\n\n    Cartesian2.fromElements(position.z, h, cartesian2Scratch);\n    const compressed1 = AttributeCompression.compressTextureCoordinates(\n      cartesian2Scratch\n    );\n\n    Cartesian2.fromElements(u, v, cartesian2Scratch);\n    const compressed2 = AttributeCompression.compressTextureCoordinates(\n      cartesian2Scratch\n    );\n\n    vertexBuffer[bufferIndex++] = compressed0;\n    vertexBuffer[bufferIndex++] = compressed1;\n    vertexBuffer[bufferIndex++] = compressed2;\n\n    if (this.hasWebMercatorT) {\n      Cartesian2.fromElements(webMercatorT, 0.0, cartesian2Scratch);\n      const compressed3 = AttributeCompression.compressTextureCoordinates(\n        cartesian2Scratch\n      );\n      vertexBuffer[bufferIndex++] = compressed3;\n    }\n  } else {\n    Cartesian3.subtract(position, this.center, cartesian3Scratch);\n\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.x;\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.y;\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.z;\n    vertexBuffer[bufferIndex++] = height;\n    vertexBuffer[bufferIndex++] = u;\n    vertexBuffer[bufferIndex++] = v;\n\n    if (this.hasWebMercatorT) {\n      vertexBuffer[bufferIndex++] = webMercatorT;\n    }\n  }\n\n  if (this.hasVertexNormals) {\n    vertexBuffer[bufferIndex++] = AttributeCompression.octPackFloat(\n      normalToPack\n    );\n  }\n\n  if (this.hasGeodeticSurfaceNormals) {\n    vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.x;\n    vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.y;\n    vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.z;\n  }\n\n  return bufferIndex;\n};\n\nconst scratchPosition = new Cartesian3();\nconst scratchGeodeticSurfaceNormal = new Cartesian3();\n\nTerrainEncoding.prototype.addGeodeticSurfaceNormals = function (\n  oldBuffer,\n  newBuffer,\n  ellipsoid\n) {\n  if (this.hasGeodeticSurfaceNormals) {\n    return;\n  }\n\n  const oldStride = this.stride;\n  const vertexCount = oldBuffer.length / oldStride;\n  this.hasGeodeticSurfaceNormals = true;\n  this._calculateStrideAndOffsets();\n  const newStride = this.stride;\n\n  for (let index = 0; index < vertexCount; index++) {\n    for (let offset = 0; offset < oldStride; offset++) {\n      const oldIndex = index * oldStride + offset;\n      const newIndex = index * newStride + offset;\n      newBuffer[newIndex] = oldBuffer[oldIndex];\n    }\n    const position = this.decodePosition(newBuffer, index, scratchPosition);\n    const geodeticSurfaceNormal = ellipsoid.geodeticSurfaceNormal(\n      position,\n      scratchGeodeticSurfaceNormal\n    );\n\n    const bufferIndex = index * newStride + this._offsetGeodeticSurfaceNormal;\n    newBuffer[bufferIndex] = geodeticSurfaceNormal.x;\n    newBuffer[bufferIndex + 1] = geodeticSurfaceNormal.y;\n    newBuffer[bufferIndex + 2] = geodeticSurfaceNormal.z;\n  }\n};\n\nTerrainEncoding.prototype.removeGeodeticSurfaceNormals = function (\n  oldBuffer,\n  newBuffer\n) {\n  if (!this.hasGeodeticSurfaceNormals) {\n    return;\n  }\n\n  const oldStride = this.stride;\n  const vertexCount = oldBuffer.length / oldStride;\n  this.hasGeodeticSurfaceNormals = false;\n  this._calculateStrideAndOffsets();\n  const newStride = this.stride;\n\n  for (let index = 0; index < vertexCount; index++) {\n    for (let offset = 0; offset < newStride; offset++) {\n      const oldIndex = index * oldStride + offset;\n      const newIndex = index * newStride + offset;\n      newBuffer[newIndex] = oldBuffer[oldIndex];\n    }\n  }\n};\n\nTerrainEncoding.prototype.decodePosition = function (buffer, index, result) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  index *= this.stride;\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    const xy = AttributeCompression.decompressTextureCoordinates(\n      buffer[index],\n      cartesian2Scratch\n    );\n    result.x = xy.x;\n    result.y = xy.y;\n\n    const zh = AttributeCompression.decompressTextureCoordinates(\n      buffer[index + 1],\n      cartesian2Scratch\n    );\n    result.z = zh.x;\n\n    return Matrix4.multiplyByPoint(this.fromScaledENU, result, result);\n  }\n\n  result.x = buffer[index];\n  result.y = buffer[index + 1];\n  result.z = buffer[index + 2];\n  return Cartesian3.add(result, this.center, result);\n};\n\nTerrainEncoding.prototype.getExaggeratedPosition = function (\n  buffer,\n  index,\n  result\n) {\n  result = this.decodePosition(buffer, index, result);\n\n  const exaggeration = this.exaggeration;\n  const exaggerationRelativeHeight = this.exaggerationRelativeHeight;\n  const hasExaggeration = exaggeration !== 1.0;\n  if (hasExaggeration && this.hasGeodeticSurfaceNormals) {\n    const geodeticSurfaceNormal = this.decodeGeodeticSurfaceNormal(\n      buffer,\n      index,\n      scratchGeodeticSurfaceNormal\n    );\n    const rawHeight = this.decodeHeight(buffer, index);\n    const heightDifference =\n      TerrainExaggeration.getHeight(\n        rawHeight,\n        exaggeration,\n        exaggerationRelativeHeight\n      ) - rawHeight;\n\n    // some math is unrolled for better performance\n    result.x += geodeticSurfaceNormal.x * heightDifference;\n    result.y += geodeticSurfaceNormal.y * heightDifference;\n    result.z += geodeticSurfaceNormal.z * heightDifference;\n  }\n\n  return result;\n};\n\nTerrainEncoding.prototype.decodeTextureCoordinates = function (\n  buffer,\n  index,\n  result\n) {\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  index *= this.stride;\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    return AttributeCompression.decompressTextureCoordinates(\n      buffer[index + 2],\n      result\n    );\n  }\n\n  return Cartesian2.fromElements(buffer[index + 4], buffer[index + 5], result);\n};\n\nTerrainEncoding.prototype.decodeHeight = function (buffer, index) {\n  index *= this.stride;\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    const zh = AttributeCompression.decompressTextureCoordinates(\n      buffer[index + 1],\n      cartesian2Scratch\n    );\n    return (\n      zh.y * (this.maximumHeight - this.minimumHeight) + this.minimumHeight\n    );\n  }\n\n  return buffer[index + 3];\n};\n\nTerrainEncoding.prototype.decodeWebMercatorT = function (buffer, index) {\n  index *= this.stride;\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    return AttributeCompression.decompressTextureCoordinates(\n      buffer[index + 3],\n      cartesian2Scratch\n    ).x;\n  }\n\n  return buffer[index + 6];\n};\n\nTerrainEncoding.prototype.getOctEncodedNormal = function (\n  buffer,\n  index,\n  result\n) {\n  index = index * this.stride + this._offsetVertexNormal;\n\n  const temp = buffer[index] / 256.0;\n  const x = Math.floor(temp);\n  const y = (temp - x) * 256.0;\n\n  return Cartesian2.fromElements(x, y, result);\n};\n\nTerrainEncoding.prototype.decodeGeodeticSurfaceNormal = function (\n  buffer,\n  index,\n  result\n) {\n  index = index * this.stride + this._offsetGeodeticSurfaceNormal;\n\n  result.x = buffer[index];\n  result.y = buffer[index + 1];\n  result.z = buffer[index + 2];\n  return result;\n};\n\nTerrainEncoding.prototype._calculateStrideAndOffsets = function () {\n  let vertexStride = 0;\n\n  switch (this.quantization) {\n    case TerrainQuantization.BITS12:\n      vertexStride += 3;\n      break;\n    default:\n      vertexStride += 6;\n  }\n  if (this.hasWebMercatorT) {\n    vertexStride += 1;\n  }\n  if (this.hasVertexNormals) {\n    this._offsetVertexNormal = vertexStride;\n    vertexStride += 1;\n  }\n  if (this.hasGeodeticSurfaceNormals) {\n    this._offsetGeodeticSurfaceNormal = vertexStride;\n    vertexStride += 3;\n  }\n\n  this.stride = vertexStride;\n};\n\nconst attributesIndicesNone = {\n  position3DAndHeight: 0,\n  textureCoordAndEncodedNormals: 1,\n  geodeticSurfaceNormal: 2,\n};\nconst attributesIndicesBits12 = {\n  compressed0: 0,\n  compressed1: 1,\n  geodeticSurfaceNormal: 2,\n};\n\nTerrainEncoding.prototype.getAttributes = function (buffer) {\n  const datatype = ComponentDatatype.FLOAT;\n  const sizeInBytes = ComponentDatatype.getSizeInBytes(datatype);\n  const strideInBytes = this.stride * sizeInBytes;\n  let offsetInBytes = 0;\n\n  const attributes = [];\n  function addAttribute(index, componentsPerAttribute) {\n    attributes.push({\n      index: index,\n      vertexBuffer: buffer,\n      componentDatatype: datatype,\n      componentsPerAttribute: componentsPerAttribute,\n      offsetInBytes: offsetInBytes,\n      strideInBytes: strideInBytes,\n    });\n    offsetInBytes += componentsPerAttribute * sizeInBytes;\n  }\n\n  if (this.quantization === TerrainQuantization.NONE) {\n    addAttribute(attributesIndicesNone.position3DAndHeight, 4);\n\n    let componentsTexCoordAndNormals = 2;\n    componentsTexCoordAndNormals += this.hasWebMercatorT ? 1 : 0;\n    componentsTexCoordAndNormals += this.hasVertexNormals ? 1 : 0;\n    addAttribute(\n      attributesIndicesNone.textureCoordAndEncodedNormals,\n      componentsTexCoordAndNormals\n    );\n\n    if (this.hasGeodeticSurfaceNormals) {\n      addAttribute(attributesIndicesNone.geodeticSurfaceNormal, 3);\n    }\n  } else {\n    // When there is no webMercatorT or vertex normals, the attribute only needs 3 components: x/y, z/h, u/v.\n    // WebMercatorT and vertex normals each take up one component, so if only one of them is present the first\n    // attribute gets a 4th component. If both are present, we need an additional attribute that has 1 component.\n    const usingAttribute0Component4 =\n      this.hasWebMercatorT || this.hasVertexNormals;\n    const usingAttribute1Component1 =\n      this.hasWebMercatorT && this.hasVertexNormals;\n    addAttribute(\n      attributesIndicesBits12.compressed0,\n      usingAttribute0Component4 ? 4 : 3\n    );\n\n    if (usingAttribute1Component1) {\n      addAttribute(attributesIndicesBits12.compressed1, 1);\n    }\n\n    if (this.hasGeodeticSurfaceNormals) {\n      addAttribute(attributesIndicesBits12.geodeticSurfaceNormal, 3);\n    }\n  }\n\n  return attributes;\n};\n\nTerrainEncoding.prototype.getAttributeLocations = function () {\n  if (this.quantization === TerrainQuantization.NONE) {\n    return attributesIndicesNone;\n  }\n  return attributesIndicesBits12;\n};\n\nTerrainEncoding.clone = function (encoding, result) {\n  if (!defined(encoding)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    result = new TerrainEncoding();\n  }\n\n  result.quantization = encoding.quantization;\n  result.minimumHeight = encoding.minimumHeight;\n  result.maximumHeight = encoding.maximumHeight;\n  result.center = Cartesian3.clone(encoding.center);\n  result.toScaledENU = Matrix4.clone(encoding.toScaledENU);\n  result.fromScaledENU = Matrix4.clone(encoding.fromScaledENU);\n  result.matrix = Matrix4.clone(encoding.matrix);\n  result.hasVertexNormals = encoding.hasVertexNormals;\n  result.hasWebMercatorT = encoding.hasWebMercatorT;\n  result.hasGeodeticSurfaceNormals = encoding.hasGeodeticSurfaceNormals;\n  result.exaggeration = encoding.exaggeration;\n  result.exaggerationRelativeHeight = encoding.exaggerationRelativeHeight;\n\n  result._calculateStrideAndOffsets();\n\n  return result;\n};\nexport default TerrainEncoding;\n"],"names":["Check","Cartesian3","defined","Ellipsoid","Rectangle","BoundingSphere","defaultValue","Cartesian2","Matrix4","TerrainQuantization","CesiumMath","AttributeCompression","ComponentDatatype"],"mappings":"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"}