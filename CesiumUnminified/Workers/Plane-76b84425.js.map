{"version":3,"file":"Plane-76b84425.js","sources":["../../../../Source/Core/Plane.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\n\n/**\n * A plane in Hessian Normal Form defined by\n * <pre>\n * ax + by + cz + d = 0\n * </pre>\n * where (a, b, c) is the plane's <code>normal</code>, d is the signed\n * <code>distance</code> to the plane, and (x, y, z) is any point on\n * the plane.\n *\n * @alias Plane\n * @constructor\n *\n * @param {Cartesian3} normal The plane's normal (normalized).\n * @param {Number} distance The shortest distance from the origin to the plane.  The sign of\n * <code>distance</code> determines which side of the plane the origin\n * is on.  If <code>distance</code> is positive, the origin is in the half-space\n * in the direction of the normal; if negative, the origin is in the half-space\n * opposite to the normal; if zero, the plane passes through the origin.\n *\n * @example\n * // The plane x=0\n * const plane = new Cesium.Plane(Cesium.Cartesian3.UNIT_X, 0.0);\n *\n * @exception {DeveloperError} Normal must be normalized\n */\nfunction Plane(normal, distance) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"normal\", normal);\n  if (\n    !CesiumMath.equalsEpsilon(\n      Cartesian3.magnitude(normal),\n      1.0,\n      CesiumMath.EPSILON6\n    )\n  ) {\n    throw new DeveloperError(\"normal must be normalized.\");\n  }\n  Check.typeOf.number(\"distance\", distance);\n  //>>includeEnd('debug');\n\n  /**\n   * The plane's normal.\n   *\n   * @type {Cartesian3}\n   */\n  this.normal = Cartesian3.clone(normal);\n\n  /**\n   * The shortest distance from the origin to the plane.  The sign of\n   * <code>distance</code> determines which side of the plane the origin\n   * is on.  If <code>distance</code> is positive, the origin is in the half-space\n   * in the direction of the normal; if negative, the origin is in the half-space\n   * opposite to the normal; if zero, the plane passes through the origin.\n   *\n   * @type {Number}\n   */\n  this.distance = distance;\n}\n\n/**\n * Creates a plane from a normal and a point on the plane.\n *\n * @param {Cartesian3} point The point on the plane.\n * @param {Cartesian3} normal The plane's normal (normalized).\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} A new plane instance or the modified result parameter.\n *\n * @example\n * const point = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\n * const normal = ellipsoid.geodeticSurfaceNormal(point);\n * const tangentPlane = Cesium.Plane.fromPointNormal(point, normal);\n *\n * @exception {DeveloperError} Normal must be normalized\n */\nPlane.fromPointNormal = function (point, normal, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"point\", point);\n  Check.typeOf.object(\"normal\", normal);\n  if (\n    !CesiumMath.equalsEpsilon(\n      Cartesian3.magnitude(normal),\n      1.0,\n      CesiumMath.EPSILON6\n    )\n  ) {\n    throw new DeveloperError(\"normal must be normalized.\");\n  }\n  //>>includeEnd('debug');\n\n  const distance = -Cartesian3.dot(normal, point);\n\n  if (!defined(result)) {\n    return new Plane(normal, distance);\n  }\n\n  Cartesian3.clone(normal, result.normal);\n  result.distance = distance;\n  return result;\n};\n\nconst scratchNormal = new Cartesian3();\n/**\n * Creates a plane from the general equation\n *\n * @param {Cartesian4} coefficients The plane's normal (normalized).\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} A new plane instance or the modified result parameter.\n *\n * @exception {DeveloperError} Normal must be normalized\n */\nPlane.fromCartesian4 = function (coefficients, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"coefficients\", coefficients);\n  //>>includeEnd('debug');\n\n  const normal = Cartesian3.fromCartesian4(coefficients, scratchNormal);\n  const distance = coefficients.w;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !CesiumMath.equalsEpsilon(\n      Cartesian3.magnitude(normal),\n      1.0,\n      CesiumMath.EPSILON6\n    )\n  ) {\n    throw new DeveloperError(\"normal must be normalized.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Plane(normal, distance);\n  }\n  Cartesian3.clone(normal, result.normal);\n  result.distance = distance;\n  return result;\n};\n\n/**\n * Computes the signed shortest distance of a point to a plane.\n * The sign of the distance determines which side of the plane the point\n * is on.  If the distance is positive, the point is in the half-space\n * in the direction of the normal; if negative, the point is in the half-space\n * opposite to the normal; if zero, the plane passes through the point.\n *\n * @param {Plane} plane The plane.\n * @param {Cartesian3} point The point.\n * @returns {Number} The signed shortest distance of the point to the plane.\n */\nPlane.getPointDistance = function (plane, point) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  return Cartesian3.dot(plane.normal, point) + plane.distance;\n};\n\nconst scratchCartesian = new Cartesian3();\n/**\n * Projects a point onto the plane.\n * @param {Plane} plane The plane to project the point onto\n * @param {Cartesian3} point The point to project onto the plane\n * @param {Cartesian3} [result] The result point.  If undefined, a new Cartesian3 will be created.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nPlane.projectPointOntoPlane = function (plane, point, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  // projectedPoint = point - (normal.point + scale) * normal\n  const pointDistance = Plane.getPointDistance(plane, point);\n  const scaledNormal = Cartesian3.multiplyByScalar(\n    plane.normal,\n    pointDistance,\n    scratchCartesian\n  );\n\n  return Cartesian3.subtract(point, scaledNormal, result);\n};\n\nconst scratchInverseTranspose = new Matrix4();\nconst scratchPlaneCartesian4 = new Cartesian4();\nconst scratchTransformNormal = new Cartesian3();\n/**\n * Transforms the plane by the given transformation matrix.\n *\n * @param {Plane} plane The plane.\n * @param {Matrix4} transform The transformation matrix.\n * @param {Plane} [result] The object into which to store the result.\n * @returns {Plane} The plane transformed by the given transformation matrix.\n */\nPlane.transform = function (plane, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  Check.typeOf.object(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  const normal = plane.normal;\n  const distance = plane.distance;\n  const inverseTranspose = Matrix4.inverseTranspose(\n    transform,\n    scratchInverseTranspose\n  );\n  let planeAsCartesian4 = Cartesian4.fromElements(\n    normal.x,\n    normal.y,\n    normal.z,\n    distance,\n    scratchPlaneCartesian4\n  );\n  planeAsCartesian4 = Matrix4.multiplyByVector(\n    inverseTranspose,\n    planeAsCartesian4,\n    planeAsCartesian4\n  );\n\n  // Convert the transformed plane to Hessian Normal Form\n  const transformedNormal = Cartesian3.fromCartesian4(\n    planeAsCartesian4,\n    scratchTransformNormal\n  );\n\n  planeAsCartesian4 = Cartesian4.divideByScalar(\n    planeAsCartesian4,\n    Cartesian3.magnitude(transformedNormal),\n    planeAsCartesian4\n  );\n\n  return Plane.fromCartesian4(planeAsCartesian4, result);\n};\n\n/**\n * Duplicates a Plane instance.\n *\n * @param {Plane} plane The plane to duplicate.\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} The modified result parameter or a new Plane instance if one was not provided.\n */\nPlane.clone = function (plane, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Plane(plane.normal, plane.distance);\n  }\n\n  Cartesian3.clone(plane.normal, result.normal);\n  result.distance = plane.distance;\n\n  return result;\n};\n\n/**\n * Compares the provided Planes by normal and distance and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Plane} left The first plane.\n * @param {Plane} right The second plane.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nPlane.equals = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return (\n    left.distance === right.distance &&\n    Cartesian3.equals(left.normal, right.normal)\n  );\n};\n\n/**\n * A constant initialized to the XY plane passing through the origin, with normal in positive Z.\n *\n * @type {Plane}\n * @constant\n */\nPlane.ORIGIN_XY_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Z, 0.0));\n\n/**\n * A constant initialized to the YZ plane passing through the origin, with normal in positive X.\n *\n * @type {Plane}\n * @constant\n */\nPlane.ORIGIN_YZ_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_X, 0.0));\n\n/**\n * A constant initialized to the ZX plane passing through the origin, with normal in positive Y.\n *\n * @type {Plane}\n * @constant\n */\nPlane.ORIGIN_ZX_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Y, 0.0));\nexport default Plane;\n"],"names":["Check","CesiumMath","Cartesian3","DeveloperError","defined","Matrix4","Cartesian4"],"mappings":"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"}